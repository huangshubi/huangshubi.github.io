<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人生在勤，不索何获。</title>
  <icon>https://www.gravatar.com/avatar/99faceb8cbf289fe061de1a792c49663</icon>
  <subtitle>学海无涯~ 学海无涯~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangbaishi.github.io/"/>
  <updated>2020-02-14T17:03:38.028Z</updated>
  <id>http://huangbaishi.github.io/</id>
  
  <author>
    <name>舒碧</name>
    <email>1732565636@qq</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协变与逆变</title>
    <link href="http://huangbaishi.github.io/2020/02/14/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
    <id>http://huangbaishi.github.io/2020/02/14/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/</id>
    <published>2020-02-14T20:43:06.000Z</published>
    <updated>2020-02-14T17:03:38.028Z</updated>
    
    <content type="html"><![CDATA[<p>记录 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/" target="_blank" rel="noopener">官方文档的协变与逆变</a>学习过程。</p><h5 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h5><p>协变与逆变能够实现数组类型、委托类型和泛型接口参数的隐式引用转换。</p><p>1、委托类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Func&lt;Bird&gt; birdFunc = () =&gt; <span class="keyword">new</span> Bird();</span><br><span class="line">            Func&lt;Animal&gt; animalFunc = () =&gt; <span class="keyword">new</span> Animal(); </span><br><span class="line">            animalFunc = birdFunc; </span><br><span class="line">            <span class="comment">//协变 Func参数使用了out关键字</span></span><br><span class="line">            Animal animal = animalFunc(); </span><br><span class="line">                      </span><br><span class="line">            Action&lt;Animal&gt; animalAction = (t) =&gt; &#123; &#125;;</span><br><span class="line">            Action&lt;Bird&gt; birdAction = animalAction;</span><br><span class="line">            <span class="comment">//逆变 Action参数使用了in关键字</span></span><br><span class="line">            birdAction(<span class="keyword">new</span> Bird()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Animal</span> &#123; &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、泛型接口和数组类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;            </span><br><span class="line">            IEnumerable&lt;Bird&gt; birds = <span class="keyword">new</span> List&lt;Bird&gt;() &#123; <span class="keyword">new</span> Bird() &#123; &#125; &#125;;           </span><br><span class="line">            IEnumerable&lt;Animal&gt; animals = birds; <span class="comment">//协变 IEnumerable&lt;out T&gt;    </span></span><br><span class="line">            <span class="keyword">var</span> enumerators = animals.GetEnumerator();</span><br><span class="line">            enumerators.MoveNext();</span><br><span class="line">            Console.WriteLine(enumerators.Current.GetType().Name); <span class="comment">//Bird</span></span><br><span class="line"></span><br><span class="line">            Animal[] animalArray = <span class="keyword">new</span> Bird[<span class="number">3</span>];</span><br><span class="line">            animalArray[<span class="number">0</span>] = <span class="keyword">new</span> Bird();</span><br><span class="line">            Console.WriteLine(animalArray[<span class="number">0</span>].GetType().Name); <span class="comment">//Bird</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.ArrayTypeMismatchException:“Attempted to access an element as a type incompatible with the array.”</span></span><br><span class="line">            animalArray[<span class="number">1</span>] = <span class="keyword">new</span> Animal(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Animal</span> &#123; &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果泛型接口或委托的泛型参数被声明为协变或逆变，该泛型接口或委托则被称为“变体”。</p><p>错误示范：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Object&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(); </span><br><span class="line"><span class="comment">//实现变体接口的类仍是固定类，这样是无法转换的。</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; integers = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();            </span><br><span class="line">IEnumerable&lt;Object&gt; objects = integers; <span class="comment">//只能用于引用类型</span></span><br></pre></td></tr></table></figure><h5 id="创建变体泛型接口"><a href="#创建变体泛型接口" class="headerlink" title="创建变体泛型接口"></a>创建变体泛型接口</h5><p>通过对泛型类型参数使用out关键字，将参数声明为协变。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface ICovariant&lt;out R&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">R <span class="title">GetSomething</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">Action&lt;R&gt; callback</span>)</span>;  <span class="comment">//逆变参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> class Implementation&lt;R&gt; : ICovariant&lt;R&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">Action&lt;R&gt; callback</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> R <span class="title">GetSomething</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过对泛型类型参数使用in关键字，将参数声明为逆变。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IContravariant&lt;in A&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSomething</span>(<span class="params">A sampleArg</span>)</span>;</span><br><span class="line">    <span class="keyword">void</span> DoSomething&lt;T&gt;() <span class="keyword">where</span> T : A;   <span class="comment">//逆变参数可以使用约束，协变不可以      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个接口，可以同时有逆变参数和协变参数，例如<code>Func&lt;in T,out TResult&gt;</code>。</p><h5 id="派生变体泛型接口"><a href="#派生变体泛型接口" class="headerlink" title="派生变体泛型接口"></a>派生变体泛型接口</h5><p>派生变体泛型接口，仍需使用in、out关键字来显示指定是否支持变体。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface ICovariant&lt;out R&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">R <span class="title">GetSomething</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">Action&lt;R&gt; callback</span>)</span>;  <span class="comment">//逆变参数</span></span><br><span class="line">&#125;</span><br><span class="line">interface  IExtCovariant&lt;out R&gt; : ICovariant&lt;R&gt; //协变参数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">interface IExtCovariantOne&lt;R&gt; : ICovariant&lt;R&gt; //固定参数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父接口参数声明为逆变，则派生接口只能和父相同，或者声明为固定参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C# Attribute</title>
    <link href="http://huangbaishi.github.io/2020/02/09/C#%20Attribute/"/>
    <id>http://huangbaishi.github.io/2020/02/09/C#%20Attribute/</id>
    <published>2020-02-09T19:24:51.000Z</published>
    <updated>2020-02-14T17:03:38.028Z</updated>
    
    <content type="html"><![CDATA[<p>记录<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/attributes/" target="_blank" rel="noopener">C#特性</a>学习过程。</p><h5 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]  <span class="comment">//表示类可以序列化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleClass</span></span><br><span class="line">&#123;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.inattribute?view=netframework-4.8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params">[In][Out] <span class="keyword">ref</span> <span class="keyword">double</span> x</span>)</span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params">[Out,In] <span class="keyword">double</span> x</span>)</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params">[Out] <span class="keyword">double</span> x</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DllImport使用 https://www.cnblogs.com/xumingming/archive/2008/10/10/1308248.html</span></span><br><span class="line">[<span class="meta">System.Runtime.InteropServices.DllImport(<span class="meta-string">"user32.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">"DEBUG"</span>), Conditional(<span class="meta-string">"TEST1"</span>)</span>] <span class="comment">//指示编译器，该特性可以指定多次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraceMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照约定，特性名称以“Attribute”结尾。 不过，在代码中使用特性时，无需指定特性后缀。</p><h5 id="显示标识特性、指定特性目标"><a href="#显示标识特性、指定特性目标" class="headerlink" title="显示标识特性、指定特性目标"></a>显示标识特性、指定特性目标</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">type: Serializable</span>]  <span class="comment">//表示类可以序列化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleClass</span></span><br><span class="line">&#123;        </span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">method: Conditional(<span class="meta-string">"DEBUG"</span>), Conditional(<span class="meta-string">"TEST1"</span>)</span>] <span class="comment">//目标是方法。 指示编译器，该特性可以指定多次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraceMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// default: applies to method</span></span><br><span class="line">[<span class="meta">ValidatedContract</span>]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Method1</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// applies to method</span></span><br><span class="line">[<span class="meta">method: ValidatedContract</span>]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Method2</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// applies to return value</span></span><br><span class="line">[<span class="meta">return: ValidatedContract</span>]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Method3</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>自定义特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制特性目标类型 AttributeTargets</span></span><br><span class="line"><span class="comment">//AllowMultiple 是否允许多次使用该特性</span></span><br><span class="line">[<span class="meta">System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = true)</span>]</span><br><span class="line">public class AuthorAttribute : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorAttribute</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        version = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Author(<span class="meta-string">"P. Ackerman"</span>, version = 1.1)</span>]</span><br><span class="line">[<span class="meta">Author(<span class="meta-string">"P. Betty"</span>, version = 1.1)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">SampleClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AttributeUsage"><a href="#AttributeUsage" class="headerlink" title="AttributeUsage"></a>AttributeUsage</h5><p>AttributeUsage是应用到自定义特性的特性。它有好几个参数，AttributeTargets：自定义特性可以有哪些特性目标，默认是全部；AllowMultiple：自定义的特性是否能在同一个特性目标上使用多次；Inherited:自定义特性是否可以有派生类继承或者重写成员继承。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            BaseClass baseClass = <span class="keyword">new</span> BaseClass();</span><br><span class="line">            DerivedClass derivedClass = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">            <span class="keyword">var</span> baseAttributes = baseClass.GetType().GetCustomAttributes();</span><br><span class="line">            <span class="keyword">var</span> derivedAttributes = derivedClass.GetType().GetCustomAttributes();            </span><br><span class="line">            Console.WriteLine(<span class="string">"BaseClass Attributes:"</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> baseAttributes)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"DerivedClass Attributes:"</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> derivedAttributes)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class, Inherited = false)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">FirstAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class)</span>] <span class="comment">//Inherited 默认值为true</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">SecondAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = true)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThirdAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.All)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">FourthAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">First, Second</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">field:Fourth</span>]</span><br><span class="line">        [<span class="meta">property:Fourth</span>]   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Third, Third</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span> &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过反射访问特性"><a href="#通过反射访问特性" class="headerlink" title="通过反射访问特性"></a>通过反射访问特性</h5><p>对类型使用自定义特性，如果任何时候都不访问该特性信息，那特性就是多余的。可以通过反射获取自定义特性信息，主要方法是<code>System.Attribute.GetCustomAttributes</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            TestAuthor.Test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestAuthor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            PrintAuthorInfo(<span class="keyword">typeof</span>(FirstClass));</span><br><span class="line">            PrintAuthorInfo(<span class="keyword">typeof</span>(SecondClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintAuthorInfo</span>(<span class="params">Type t</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            System.Console.WriteLine(<span class="string">"Author information for &#123;0&#125;"</span>, t);</span><br><span class="line">            </span><br><span class="line">            System.Attribute[] attrs = System.Attribute.GetCustomAttributes(t);  </span><br><span class="line">            <span class="keyword">foreach</span> (System.Attribute attr <span class="keyword">in</span> attrs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (attr <span class="keyword">is</span> AuthorAttribute author)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.Console.WriteLine(<span class="string">"&#123;0&#125;, version &#123;1:f&#125;"</span>, author.GetName(), author.version);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制特性目标类型 AttributeTargets</span></span><br><span class="line">    <span class="comment">//AllowMultiple 是否允许多次使用该特性</span></span><br><span class="line">    [<span class="meta">System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = true)</span>]</span><br><span class="line">    public class AuthorAttribute : System.Attribute</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> version;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AuthorAttribute</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            version = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Author(<span class="meta-string">"P. Ackerman"</span>, version = 1.1)</span>]</span><br><span class="line">    [<span class="meta">Author(<span class="meta-string">"P. Betty"</span>, version = 1.2)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">FirstClass</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Author(<span class="meta-string">"P. Betty"</span>, version = 1.22)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SecondClass</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h5><p>ObsoleteAttribute,标记不再使用的元素。使用该特性时，最好传入参数提示。该特性不能被继承。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Obsolete(<span class="meta-string">"use class B"</span>)</span>] <span class="comment">//使用该方法，给予警告，但是不报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//第二个参数error如果true，使用该方法则编译报错</span></span><br><span class="line">    [<span class="meta">System.Obsolete(<span class="meta-string">"use NewMethod"</span>, true)</span>] </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldMethod</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NewMethod</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConditionalAttribute  使得方法是否执行依赖于预处理标识符。自定义的预处理标识符：项目-&gt;属性-&gt;生成-&gt;条件编译和符号。也可以使用#define预处理指令。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;           </span><br><span class="line">            DoIfAorB(); </span><br><span class="line">            DoIfA(); <span class="comment">//条件编译符号 有A和B才执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">"A"</span>), Conditional(<span class="meta-string">"B"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoIfAorB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"DoIfAorB"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">"A"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoIfA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DoIfAandB();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">"B"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoIfAandB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"DoIfA AND B"</span>);</span><br><span class="line">            <span class="comment">// Code to execute when both A and B are defined...  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConditionalAttribute通常与DEBUG标识符一起使用。代替 #if DEBUG #endif …</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            CheckMethod();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">"DEBUG"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CheckMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">"debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方特性</p><p>CallerMemberName、CallerFilePath、CallerLineNumber ，都只能应用于参数，且参数必须有默认值。如果调用方没有传入值，则参数值是运行时得到的调用方信息。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DoProcessing();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            TraceMessage(<span class="string">"Something happened."</span>);</span><br><span class="line">            TraceMessage(<span class="string">"Something happened11."</span>,sourceFilePath:<span class="string">"...path"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TraceMessage</span>(<span class="params"><span class="keyword">string</span> message,</span></span></span><br><span class="line"><span class="function"><span class="params">                [System.Runtime.CompilerServices.CallerMemberName] <span class="keyword">string</span> memberName = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                [System.Runtime.CompilerServices.CallerFilePath] <span class="keyword">string</span> sourceFilePath = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                [System.Runtime.CompilerServices.CallerLineNumber] <span class="keyword">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            System.Diagnostics.Trace.WriteLine(<span class="string">"message: "</span> + message);</span><br><span class="line">            System.Diagnostics.Trace.WriteLine(<span class="string">"member name: "</span> + memberName);</span><br><span class="line">            System.Diagnostics.Trace.WriteLine(<span class="string">"source file path: "</span> + sourceFilePath);</span><br><span class="line">            System.Diagnostics.Trace.WriteLine(<span class="string">"source line number: "</span> + sourceLineNumber);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">message: Something happened.</span><br><span class="line">member name: DoProcessing</span><br><span class="line">source file path: C:\Users\bibi\Desktop\代码\异步\ConsoleApp4\Program.cs</span><br><span class="line">source line number: <span class="number">16</span></span><br><span class="line">message: Something happened11.</span><br><span class="line">member name: DoProcessing</span><br><span class="line">source file path: ...path</span><br><span class="line">source line number: <span class="number">17</span></span><br></pre></td></tr></table></figure><h5 id="程序集特性"><a href="#程序集特性" class="headerlink" title="程序集特性"></a>程序集特性</h5><p> AssemblyInfo.cs 文件放着程序集全局特性。分三种：唯一标识特性（例如：AssemblyVersionAttribute）、公司或产品信息特性（例如AssemblyCompanyAttribute）、程序集功能特性(例如：AssemblyTitleAttribute)。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/attributes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C#特性&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="Attribute" scheme="http://huangbaishi.github.io/tags/Attribute/"/>
    
  </entry>
  
  <entry>
    <title>动态编程</title>
    <link href="http://huangbaishi.github.io/2020/02/04/%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    <id>http://huangbaishi.github.io/2020/02/04/%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T16:54:23.000Z</published>
    <updated>2020-02-14T17:03:38.028Z</updated>
    
    <content type="html"><![CDATA[<p>记录《Effective C#》C#7.0 学习过程，但是用的是C#版本7.3验证书中例子,书中有些内容是对不上的。<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/configure-language-version" target="_blank" rel="noopener">配置语言版本</a></p><h5 id="动态编程的优缺点"><a href="#动态编程的优缺点" class="headerlink" title="动态编程的优缺点"></a>动态编程的优缺点</h5><p>假如实现一通用加法，参数类型只要求支持特定的操作符，使用泛型是无法实现这种约束的，但动态类型就灵活很多了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">dynamic</span> <span class="title">Add</span>(<span class="params"><span class="keyword">dynamic</span> a, <span class="keyword">dynamic</span> b</span>) <span class="comment">//动态类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b; <span class="comment">//在运行时才会对类型进行解析。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是运行时才对动态类型解析，因此问题也会延迟暴露。</p><p>连锁的动态类型，运算过程中如果有动态类型，那结果也是动态类型，要变成静态类型，只能自己转换类型。（缺 可能C#7.0以后可以自动转了，C#7.3可以自动转）</p><p>如果编码无法提前知道对象的类型，并且在运行时要调用某个特定的方法，可以考虑动态编程。其他情应使用lambda表达式或其他函数式编程实现。（建议）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> lambdaAnswer = Add(<span class="number">3</span>, <span class="number">3</span>, (a, b) =&gt; a + b);  <span class="comment">//传入lambda表达式1</span></span><br><span class="line">     <span class="keyword">var</span> lambdaAnswer1 = Add(<span class="string">"args"</span>, <span class="number">3</span>, (a, b) =&gt; a + b.ToString());<span class="comment">//传入lambda表达式2</span></span><br><span class="line">     <span class="keyword">var</span> lambdaAnswer1 = Add(<span class="number">4</span>, <span class="number">3.4</span>m, (a, b) =&gt; a + (<span class="keyword">int</span>)b);<span class="comment">//传入lambda表达式3     </span></span><br><span class="line"> &#125;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TResult Add&lt;T1,T2,TResult&gt;(T1 left,T2 right,Func&lt;T1,T2,TResult&gt; addMethod)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addMethod(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的表达式可以衍生出表达式树的写法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static class BinaryOperator&lt;T&gt;  //如果操作数和运算结果同一类型，建议该写法</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Func&lt;T,T,T&gt; compiledExpression; <span class="comment">//缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Add</span>(<span class="params">T left, T right</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (compiledExpression == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CreatFunc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compiledExpression(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreatFunc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> leftOperand = Expression.Parameter(<span class="keyword">typeof</span>(T), <span class="string">"left"</span>);</span><br><span class="line">        <span class="keyword">var</span> rightOperand = Expression.Parameter(<span class="keyword">typeof</span>(T), <span class="string">"right"</span>);</span><br><span class="line">        <span class="keyword">var</span> body = Expression.Add(leftOperand, rightOperand);</span><br><span class="line">        <span class="keyword">var</span> adder = Expression.Lambda&lt;Func&lt;T,T,T&gt;&gt;(body, leftOperand, rightOperand);</span><br><span class="line">        compiledExpression = adder.Compile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public static class BinaryOperator&lt;T1, T2, TResult&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">static</span> Func&lt;T1, T2, TResult&gt; compiledExpression;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TResult <span class="title">Add</span>(<span class="params">T1 left,T2 right</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="keyword">if</span> (compiledExpression == <span class="literal">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             CreatFunc();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> compiledExpression(left, right);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreatFunc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="keyword">var</span> leftOperand = Expression.Parameter(<span class="keyword">typeof</span>(T1), <span class="string">"left"</span>);</span><br><span class="line">         <span class="keyword">var</span> rightOperand = Expression.Parameter(<span class="keyword">typeof</span>(T2), <span class="string">"right"</span>);</span><br><span class="line"></span><br><span class="line">         Expression convertedLeft = leftOperand;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span>(T1) != <span class="keyword">typeof</span>(TResult))</span><br><span class="line">         &#123;</span><br><span class="line">             convertedLeft = Expression.Convert(leftOperand, <span class="keyword">typeof</span>(TResult)); <span class="comment">//转换</span></span><br><span class="line">         &#125;</span><br><span class="line">         Expression convertedRight = rightOperand;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span>(T2) != <span class="keyword">typeof</span>(TResult))</span><br><span class="line">         &#123;</span><br><span class="line">             convertedRight = Expression.Convert(rightOperand, <span class="keyword">typeof</span>(TResult));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> body = Expression.Add(convertedLeft, convertedRight);</span><br><span class="line">         <span class="keyword">var</span> adder = Expression.Lambda&lt;Func&lt;T1, T2, TResult&gt;&gt;(body, leftOperand, rightOperand); </span><br><span class="line">         compiledExpression = adder.Compile();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>C#写出的动态程序（例如表达式树、dynamic…）都是在运行时做检查，效率是没有静态类型的快。</p><p>先静后动：通过接口或基类实现，lambda表达式，表达式树，动态类型。</p><h5 id="动态编程技术可以帮助运行泛型参数的运行期类型的运用"><a href="#动态编程技术可以帮助运行泛型参数的运行期类型的运用" class="headerlink" title="动态编程技术可以帮助运行泛型参数的运行期类型的运用"></a>动态编程技术可以帮助运行泛型参数的运行期类型的运用</h5><p>在<code>System.Core</code>程序集里，<code>System.Linq.Enumerable.Cast&lt;T&gt;</code>的扩展方法可以把序列中的每个元素转换成T类型，但是如果对T没有约束，<code>Cast&lt;T&gt;</code>方法只能认定T类型含有的那些<code>System.Object</code>的成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; strList = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            strList.Add(<span class="string">"aa"</span>);</span><br><span class="line">            strList.Add(<span class="string">"bb"</span>);</span><br><span class="line">            strList.Add(<span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> results = strList.Cast&lt;MyType&gt;(); <span class="comment">//惰性 延迟转换</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//和上面写法一个意思</span></span><br><span class="line">            <span class="comment">//var results = from MyType v in strList  </span></span><br><span class="line">                           <span class="comment">//select v;</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> results)  </span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InvalidCastException) <span class="comment">//无效转换异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果运行失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyType</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> StringMember &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不推荐设计Api时使用隐式转换器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">String</span>(<span class="params">MyType aString</span>)</span> =&gt; aString.StringMember;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">MyType</span>(<span class="params">String aString</span>)</span> =&gt; <span class="keyword">new</span> MyType &#123; StringMember = aString &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; strList = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();  </span><br><span class="line">    <span class="comment">//是System.Object含有的那些成员，不会报无效转换异常。</span></span><br><span class="line">    </span><br><span class="line">    strList.Add(<span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> results = strList.Cast&lt;<span class="keyword">string</span>&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> results)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法1：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> results = <span class="keyword">from</span> MyType v <span class="keyword">in</span> strList  </span><br><span class="line">                           <span class="keyword">select</span> v;</span><br><span class="line">换成</span><br><span class="line"><span class="keyword">var</span> results = <span class="keyword">from</span> v <span class="keyword">in</span> strList  </span><br><span class="line">                           <span class="keyword">select</span> (MyType)v;  <span class="comment">//select方法接受的是lambda表达式，对于v来说，lambda表达式是string类型的对象</span></span><br></pre></td></tr></table></figure><p>解决办法2：<code>strList.Select(a =&gt; new MyType { StringMember = a });</code></p><p>解决办法3：使用构造函数。</p><p>解决办法4：大量反射代码，知道拿到转换器，但是效率不如动态类型。</p><p>最后：动态类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 枚举扩展类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnumerableExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;TResult&gt; Convert&lt;TResult&gt;(<span class="keyword">this</span> System.Collections.IEnumerable sequence)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">object</span> item <span class="keyword">in</span> sequence)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">dynamic</span> result = (<span class="keyword">dynamic</span>)item;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">TResult</span>)result</span>; <span class="comment">//yield 迭代返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用DynamicObject实现数据驱动的动态类型</p><p>直接继承DynamicObject，访问属性，会报动态绑定错误。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> dynamicProperties = <span class="keyword">new</span> DynamicPropertyBag();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        dynamicProperties.Date = DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(RuntimeBinderException ex)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，覆盖原来的TryGetMember、TrySetMember方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DynamicPropertyBag</span> : <span class="title">DynamicObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt; storage = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TryGetMember</span>(<span class="params">GetMemberBinder binder, <span class="keyword">out</span> <span class="keyword">object</span> result</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (storage.ContainsKey(binder.Name))</span><br><span class="line">        &#123;</span><br><span class="line">            result = storage[binder.Name];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TrySetMember</span>(<span class="params">SetMemberBinder binder, <span class="keyword">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> key = binder.Name;</span><br><span class="line">        <span class="keyword">if</span> (storage.ContainsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            storage[key] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            storage.Add(key, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LINQ TO XML不是特别好用。如果想实现A元素.B元素[“C”,3]这样的链式，和两个同级索引获取值方法，可以覆盖DynamicObject的TryGetMember方法、TryGetIndex方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicXElement</span> : <span class="title">DynamicObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> XElement xmlSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicXElement</span>(<span class="params">XElement source</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        xmlSource = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TryGetMember</span>(<span class="params">GetMemberBinder binder, <span class="keyword">out</span> <span class="keyword">object</span> result</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlSource == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (binder.Name == <span class="string">"Value"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (binder.Name == <span class="string">"Value"</span>)</span><br><span class="line">                result = xmlSource.Value;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result = <span class="keyword">new</span> DynamicXElement(xmlSource.Element(XName.Get(binder.Name)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TryGetIndex</span>(<span class="params">GetIndexBinder binder, <span class="keyword">object</span>[] indexes, <span class="keyword">out</span> <span class="keyword">object</span> result</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (indexes.Length != <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(indexes[<span class="number">0</span>] <span class="keyword">is</span> <span class="keyword">string</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(indexes[<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">int</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (xmlSource == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> allnodes = xmlSource.Elements(indexes[<span class="number">0</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> index = (<span class="keyword">int</span>)indexes[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; allnodes.Count())</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">new</span> DynamicXElement(allnodes.ElementAt(index));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Expression-API"><a href="#Expression-API" class="headerlink" title="Expression API"></a>Expression API</h5><p>WCF、Web服务等常针对某项服务生成对于的代理，如果服务器那边更新了方法，客户端代理需要相应的更新。但是使用Express API，就相对简单。</p><p>创建能够接受Expression的方法，把某套逻辑传入该方法，该方法对其进行解析。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一个简单的例子：服务方法的参数是常量，打印方法名，参数类型，参数值。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> client = <span class="keyword">new</span> ClientProxy&lt;IService&gt;();</span><br><span class="line">            client.CallInterface&lt;<span class="keyword">string</span>&gt;(server=&gt;server.DoWork(<span class="number">666</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    public class ClientProxy&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> TResult CallInterface&lt;TResult&gt;(Expression&lt;Func&lt;T,TResult&gt;&gt; op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> exp = op.Body <span class="keyword">as</span> MethodCallExpression; <span class="comment">//静态方法或实例方法的调用</span></span><br><span class="line">            <span class="keyword">var</span> methodName = exp.Method.Name;</span><br><span class="line">            <span class="keyword">var</span> methodInfo = exp.Method;</span><br><span class="line">            <span class="keyword">var</span> allParameters = <span class="keyword">from</span> element <span class="keyword">in</span> exp.Arguments</span><br><span class="line">                                <span class="function"><span class="keyword">select</span> <span class="title">ProcessArgument</span>(<span class="params">element</span>)</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$"Calling <span class="subst">&#123;methodName&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> param <span class="keyword">in</span> allParameters)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$"\tParameter type=<span class="subst">&#123;param.ParamType&#125;</span> value=<span class="subst">&#123;param.ParamValue&#125;</span>"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如何动态的传入参数     ？？？？？？？？？？？？？？？？？？？？？？</span></span><br><span class="line">            <span class="comment">//????????????????????????????</span></span><br><span class="line">            <span class="comment">//var result = op.Compile();// (()allParameters.First().ParamValue); </span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">default</span>(TResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理的参数是个常量</span></span><br><span class="line">        <span class="keyword">private</span> (Type ParamType,<span class="keyword">object</span> ParamValue) ProcessArgument(Expression element)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过先构造一个委托类型来创建一个 System.Linq.Expressions.LambdaExpression。</span></span><br><span class="line">            LambdaExpression expression = Expression.Lambda(Expression.Convert(element, element.Type));</span><br><span class="line">            <span class="comment">//获取lambda返回的类型</span></span><br><span class="line">            Type paramType = expression.ReturnType;</span><br><span class="line">            <span class="comment">//动态调用当前委托表示的方法</span></span><br><span class="line">            <span class="keyword">var</span> argument = expression.Compile().DynamicInvoke();</span><br><span class="line">            <span class="keyword">return</span> (paramType, argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">string</span> <span class="title">DoWork</span>(<span class="params"><span class="keyword">int</span> number</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImplementService</span> : <span class="title">IService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">DoWork</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态的类型转换器，编写可以在运行期自动产生代码的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">var</span> converter = <span class="keyword">new</span> Converter&lt;Source,Dest&gt;();</span><br><span class="line">           Source source = <span class="keyword">new</span> Source();</span><br><span class="line">           source.AA = <span class="string">"AA"</span>;</span><br><span class="line">           source.BB = <span class="number">22</span>;</span><br><span class="line">           source.CC = <span class="number">66</span>;</span><br><span class="line">           source.EE = <span class="number">88</span>;</span><br><span class="line">           <span class="keyword">var</span> dest = converter.ConvertFrom(source);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class Converter&lt;TSource, TDest&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       Func&lt;TSource, TDest&gt; converter;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> TDest <span class="title">ConvertFrom</span>(<span class="params">TSource source</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">if</span> (converter == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">                CreateConverter();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> converter(source);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateConverter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="comment">//创建一个ParameterExpression节点，标识表达式树中的参数或变量</span></span><br><span class="line">           <span class="keyword">var</span> source = Expression.Parameter(<span class="keyword">typeof</span>(TSource), <span class="string">"source"</span>);</span><br><span class="line">           <span class="comment">//创建一个ParameterExpression节点，标识表达式树中的参数或变量</span></span><br><span class="line">           <span class="keyword">var</span> dest = Expression.Variable(<span class="keyword">typeof</span>(TDest), <span class="string">"dest"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> assignments = <span class="keyword">from</span> srcProp <span class="keyword">in</span></span><br><span class="line">                                 <span class="keyword">typeof</span>(TSource).</span><br><span class="line">                                 GetProperties(BindingFlags.Public | BindingFlags.Instance)</span><br><span class="line">                             <span class="keyword">where</span> srcProp.CanRead</span><br><span class="line">                             <span class="keyword">let</span> destProp = <span class="keyword">typeof</span>(TDest).GetProperty(srcProp.Name, BindingFlags.Public | BindingFlags.Instance)</span><br><span class="line">                             <span class="keyword">where</span> (destProp != <span class="literal">null</span>) &amp;&amp; (destProp.CanWrite)</span><br><span class="line">                             <span class="keyword">select</span> Expression.Assign(Expression.Property(dest, destProp), Expression.Property(source, srcProp));</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> body = <span class="keyword">new</span> List&lt;Expression&gt;();</span><br><span class="line">           body.Add(Expression.Assign(dest,Expression.New(<span class="keyword">typeof</span>(TDest))));</span><br><span class="line">           body.AddRange(assignments);</span><br><span class="line">           body.Add(dest);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> expr = Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(Expression.Block(<span class="keyword">new</span>[] &#123; dest&#125;,body.ToArray()),source);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> func = expr.Compile();</span><br><span class="line">           converter = func;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Source</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">string</span> AA &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> BB &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">double</span> CC &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">double</span> DD &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//无法赋值</span></span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">double</span> EE &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//无法赋值</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dest</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">string</span> AA &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> BB &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">double</span> CC &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">double</span> DD &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> EE &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>每当想使用反射编程时候，首先应该考虑能不能改用效率更高的Expression API。</p><h5 id="减少公有API中的动态对象"><a href="#减少公有API中的动态对象" class="headerlink" title="减少公有API中的动态对象"></a>减少公有API中的动态对象</h5><p>动态对象具有传染性，建议API返回静态类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> a = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">""</span>; <span class="comment">//b是动态类型</span></span><br></pre></td></tr></table></figure><p>动态对象在越小的范围使用越好。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种:不好的API,需要传入动态类型参数。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">dynamic</span> <span class="title">Add</span>(<span class="params"><span class="keyword">dynamic</span> a, <span class="keyword">dynamic</span> b</span>) <span class="comment">//动态类型</span></span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b; <span class="comment">//在运行时才会对类型进行解析。</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//改良 参数改为泛型，返回类型转为静态</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TResult Add&lt;T1,T2,TResult&gt;(T1 t1,T2 t2)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> (TResult)Add(t1, t2);</span><br><span class="line">      <span class="function"><span class="keyword">dynamic</span> <span class="title">Add</span>(<span class="params"><span class="keyword">dynamic</span> t11,<span class="keyword">dynamic</span> t12</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          <span class="keyword">return</span> t11 + t12;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有时候，确实需要把动态对象放到接口中，但不代表整个接口都是动态代码，只应该把要依赖动态对象才能运作的成员设计成动态的。</p><p>举例：<a href="https://github.com/JoshClose/CsvHelper" target="_blank" rel="noopener">https://github.com/JoshClose/CsvHelper</a> ，CSV数据的读取器。</p><p>1: 建立一个文本文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">列1 ,列2 , 列3</span><br><span class="line">11 ,2222 ,3333 </span><br><span class="line">12 ,2223 ,3334 </span><br><span class="line">13 ,2224 ,3335</span><br></pre></td></tr></table></figure><p>2: 这里的CSVRow虽然设计为内部私有类，但是TryGetMember是覆盖了父类的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> data = <span class="keyword">new</span> CSVDataContainer(<span class="keyword">new</span> System.IO.StreamReader(<span class="string">@"C:\Users\bibi\Desktop\代码\异步\ConsoleApp1\TextFile1.txt"</span>));</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> data.Rows)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$"<span class="subst">&#123;item.列<span class="number">1</span>&#125;</span> <span class="subst">&#123;item.列<span class="number">2</span>&#125;</span> <span class="subst">&#123;item.列<span class="number">3</span>&#125;</span>"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">dynamic</span> a = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">var</span> b = a + <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> TResult Add&lt;T1,T2,TResult&gt;(T1 t1,T2 t2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (TResult)Add(t1, t2);</span><br><span class="line">            <span class="function"><span class="keyword">dynamic</span> <span class="title">Add</span>(<span class="params"><span class="keyword">dynamic</span> t11,<span class="keyword">dynamic</span> t12</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> t11 + t12;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSVDataContainer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">CSVRow</span> : <span class="title">DynamicObject</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> List&lt;(<span class="keyword">string</span>, <span class="keyword">string</span>)&gt; values = <span class="keyword">new</span> List&lt;(<span class="keyword">string</span>, <span class="keyword">string</span>)&gt;();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">CSVRow</span>(<span class="params">IEnumerable&lt;<span class="keyword">string</span>&gt; headers,IEnumerable&lt;<span class="keyword">string</span>&gt; items</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                values.AddRange(headers.Zip(items, (header, <span class="keyword">value</span>) =&gt; (header, <span class="keyword">value</span>)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//虽然CSVRow是私有，但这个依然可以覆盖。</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TryGetMember</span>(<span class="params">GetMemberBinder binder, <span class="keyword">out</span> <span class="keyword">object</span> result</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">var</span> answer = values.FirstOrDefault(n =&gt; n.Item1 == binder.Name);</span><br><span class="line">                result = answer.Item2;</span><br><span class="line">                <span class="keyword">return</span> result != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;<span class="keyword">string</span>&gt; columnNames = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">        <span class="keyword">private</span> List&lt;CSVRow&gt; data = <span class="keyword">new</span> List&lt;CSVRow&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CSVDataContainer</span>(<span class="params">System.IO.TextReader stream</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> headers = stream.ReadLine();</span><br><span class="line">            columnNames = (<span class="keyword">from</span> header <span class="keyword">in</span> headers.Split(<span class="string">','</span>) <span class="keyword">select</span> header.Trim()).ToList();</span><br><span class="line">            <span class="keyword">var</span> line = stream.ReadLine();</span><br><span class="line">            <span class="keyword">while</span>(line != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> items = line.Split(<span class="string">','</span>);</span><br><span class="line">                data.Add(<span class="keyword">new</span> CSVRow(columnNames, items));</span><br><span class="line">                line = stream.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]=&gt;data[index];</span><br><span class="line">        <span class="keyword">public</span> IEnumerable&lt;<span class="keyword">dynamic</span>&gt; Rows =&gt; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录《Effective C#》C#7.0 学习过程，但是用的是C#版本7.3验证书中例子,书中有些内容是对不上的。&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/conf
      
    
    </summary>
    
    
    
      <category term="Dynamic" scheme="http://huangbaishi.github.io/tags/Dynamic/"/>
    
      <category term="DynamicObject" scheme="http://huangbaishi.github.io/tags/DynamicObject/"/>
    
      <category term="Expression" scheme="http://huangbaishi.github.io/tags/Expression/"/>
    
      <category term="LambdaExpression" scheme="http://huangbaishi.github.io/tags/LambdaExpression/"/>
    
  </entry>
  
  <entry>
    <title>并行处理</title>
    <link href="http://huangbaishi.github.io/2020/01/30/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <id>http://huangbaishi.github.io/2020/01/30/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/</id>
    <published>2020-01-30T13:03:58.000Z</published>
    <updated>2020-02-14T17:03:38.028Z</updated>
    
    <content type="html"><![CDATA[<p>记录《Effective C#》学习过程。</p><h5 id="通过Parallel-LINQ-PLINQ-实现并行算法"><a href="#通过Parallel-LINQ-PLINQ-实现并行算法" class="headerlink" title="通过Parallel LINQ  (PLINQ) 实现并行算法"></a>通过Parallel LINQ  (PLINQ) 实现并行算法</h5><p>通过使用PLINQ提供的方法，可以简单的写出发挥多核CPU优势的代码，也会有线程开销。</p><p>对数据源调用AsParallel()方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;Student&gt;() &#123;</span><br><span class="line">           <span class="keyword">new</span> Student()&#123;Age=<span class="number">10</span> &#125;,<span class="keyword">new</span> Student()&#123; Age=<span class="number">9</span>&#125;,<span class="keyword">new</span> Student()&#123; Age=<span class="number">9</span>&#125;,<span class="keyword">new</span> Student()&#123; Age=<span class="number">9</span>&#125;</span><br><span class="line">           <span class="keyword">new</span> Student()&#123; Age=<span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//linq to objects</span></span><br><span class="line">           IEnumerable&lt;Student&gt; filterStudents = students.Where(m =&gt; m.Age &lt; <span class="number">10</span>).</span><br><span class="line">               Select(n =&gt; SetStudent(n));</span><br><span class="line"></span><br><span class="line">           <span class="comment">//对数据源做AsParallel处理 不涉及数据共享，元素顺序没有特定要求。</span></span><br><span class="line">           <span class="comment">//public class ParallelQuery&lt;TSource&gt; : ParallelQuery, IEnumerable&lt;TSource&gt;, IEnumerable</span></span><br><span class="line">           ParallelQuery&lt;Student&gt; filterStudents1 = students.AsParallel().Where(m =&gt; m.Age &lt; <span class="number">10</span>).</span><br><span class="line">               Select(n =&gt; SetStudent(n));</span><br><span class="line"></span><br><span class="line">           <span class="comment">//linq to sql</span></span><br><span class="line">           <span class="keyword">var</span> filterStudents2 = <span class="keyword">from</span> m <span class="keyword">in</span> students</span><br><span class="line">                                 <span class="keyword">where</span> m.Age &lt; <span class="number">10</span></span><br><span class="line">                                 <span class="function"><span class="keyword">select</span> <span class="title">SetStudent</span>(<span class="params">m</span>)</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> filterStudents3 = <span class="keyword">from</span> m <span class="keyword">in</span> students.AsParallel()</span><br><span class="line">                                 <span class="keyword">where</span> m.Age &lt; <span class="number">10</span></span><br><span class="line">                                 <span class="function"><span class="keyword">select</span> <span class="title">SetStudent</span>(<span class="params">m</span>)</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Student <span class="title">SetStudent</span>(<span class="params">Student student</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           student.TeacherName = <span class="string">"李楚刀"</span>;</span><br><span class="line">           <span class="keyword">return</span> student;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">string</span> TeacherName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数据划分，当执行并行查询的时候，第一个步骤是划分数据，划分数据方式包括范围划分、区块划分、带状划分、哈希划分。PLINQ自动的使用适当的算法对数据进行分区，并行并行执行查询的各个部分，然后合并结果。<a href="https://docs.microsoft.com/en-in/archive/msdn-magazine/2009/december/concurrent-affairs-data-parallel-patterns-and-plinq" target="_blank" rel="noopener">数据并行模式和PLINQ</a>。</p><p>并行执行任务的算法：pipelining、 stop and go、inverted enumeration</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         <span class="comment">//采用 stop &amp; go 算法</span></span><br><span class="line">       <span class="keyword">var</span> filterStudents3 = (<span class="keyword">from</span> m <span class="keyword">in</span> students.AsParallel()</span><br><span class="line">                               <span class="keyword">where</span> m.Age &lt; <span class="number">10</span></span><br><span class="line">                               <span class="function"><span class="keyword">select</span> <span class="title">SetStudent</span>(<span class="params">m</span>)).<span class="title">ToList</span>(<span class="params"></span>)</span>;</span><br><span class="line">         <span class="comment">//采用 stop &amp; go 算法</span></span><br><span class="line">         <span class="keyword">var</span> filterStudents4 = (<span class="keyword">from</span> m <span class="keyword">in</span> students.AsParallel()</span><br><span class="line">                                <span class="keyword">where</span> m.Age &lt; <span class="number">10</span></span><br><span class="line">                                <span class="function"><span class="keyword">select</span> <span class="title">SetStudent</span>(<span class="params">m</span>)).<span class="title">ToArray</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//采用 inverted enumeration 算法 </span></span><br><span class="line">         <span class="keyword">var</span> filterStudents5 = <span class="keyword">from</span> m <span class="keyword">in</span> students.AsParallel()</span><br><span class="line">                                <span class="keyword">where</span> m.Age &lt; <span class="number">10</span></span><br><span class="line">                                <span class="function"><span class="keyword">select</span> <span class="title">SetStudent</span>(<span class="params">m</span>)</span>;</span><br><span class="line"><span class="comment">//一边计算结果 一边对已经计算出来的元素并行地操作</span></span><br><span class="line">         filterStudents5.ForAll(item =&gt; Console.WriteLine(item));</span><br></pre></td></tr></table></figure><p>LINQ to Objects 是以懒性的方式对查询操作进行求值，只有真正用到查询结果某个值的时候，系统才会去生成。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> answer = <span class="keyword">from</span> n <span class="keyword">in</span> Enumerable.Range(<span class="number">0</span>, <span class="number">300</span>)</span><br><span class="line">                         <span class="keyword">where</span> n.SomeTest()</span><br><span class="line">                         <span class="keyword">select</span> n.SomeProjection();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> iter = answer.GetEnumerator();</span><br><span class="line">            Console.WriteLine(<span class="string">"start iterating"</span>);</span><br><span class="line">            <span class="keyword">while</span> (iter.MoveNext()) </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"called MoveNext"</span>);</span><br><span class="line">                Console.WriteLine(iter.Current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SomeTest</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">int</span> inputValue</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"testing element:<span class="subst">&#123;inputValue&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span> inputValue % <span class="number">10</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">SomeProjection</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">int</span> input</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"projecting an element:<span class="subst">&#123;input&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Delivered <span class="subst">&#123;input&#125;</span> at <span class="subst">&#123;DateTime.Now:T&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">截取部分结果说明：</span><br><span class="line">start iterating</span><br><span class="line">testing element:<span class="number">0</span></span><br><span class="line">projecting an element:<span class="number">0</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">0</span> at <span class="number">15</span>:<span class="number">45</span>:<span class="number">36</span></span><br><span class="line">testing element:<span class="number">1</span></span><br><span class="line">testing element:<span class="number">2</span></span><br><span class="line">testing element:<span class="number">3</span></span><br><span class="line">testing element:<span class="number">4</span></span><br><span class="line">testing element:<span class="number">5</span></span><br><span class="line">testing element:<span class="number">6</span></span><br><span class="line">testing element:<span class="number">7</span></span><br><span class="line">testing element:<span class="number">8</span></span><br><span class="line">testing element:<span class="number">9</span></span><br><span class="line">testing element:<span class="number">10</span></span><br><span class="line">projecting an element:<span class="number">10</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">10</span> at <span class="number">15</span>:<span class="number">45</span>:<span class="number">36</span></span><br><span class="line">testing element:<span class="number">11</span>   又去查询元素</span><br><span class="line">testing element:<span class="number">12</span></span><br><span class="line">testing element:<span class="number">13</span></span><br><span class="line">testing element:<span class="number">14</span></span><br><span class="line">testing element:<span class="number">15</span></span><br><span class="line">testing element:<span class="number">16</span></span><br><span class="line">testing element:<span class="number">17</span></span><br><span class="line">testing element:<span class="number">18</span></span><br><span class="line">testing element:<span class="number">19</span></span><br><span class="line">testing element:<span class="number">20</span></span><br><span class="line">projecting an element:<span class="number">20</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">20</span> at <span class="number">15</span>:<span class="number">45</span>:<span class="number">36</span></span><br><span class="line">testing element:<span class="number">21</span></span><br><span class="line">testing element:<span class="number">22</span></span><br><span class="line">testing element:<span class="number">23</span></span><br><span class="line">testing element:<span class="number">24</span></span><br><span class="line">testing element:<span class="number">25</span></span><br><span class="line">testing element:<span class="number">26</span></span><br><span class="line">testing element:<span class="number">27</span></span><br><span class="line">testing element:<span class="number">28</span></span><br><span class="line">testing element:<span class="number">29</span></span><br><span class="line">testing element:<span class="number">30</span></span><br><span class="line">projecting an element:<span class="number">30</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">30</span> at <span class="number">15</span>:<span class="number">45</span>:<span class="number">36</span></span><br><span class="line">testing element:<span class="number">31</span></span><br><span class="line">testing element:<span class="number">32</span></span><br><span class="line">testing element:<span class="number">33</span></span><br><span class="line">testing element:<span class="number">34</span></span><br><span class="line">testing element:<span class="number">35</span></span><br><span class="line">testing element:<span class="number">36</span></span><br><span class="line">testing element:<span class="number">37</span></span><br><span class="line">testing element:<span class="number">38</span></span><br><span class="line">testing element:<span class="number">39</span></span><br><span class="line">testing element:<span class="number">40</span></span><br><span class="line">projecting an element:<span class="number">40</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">40</span> at <span class="number">15</span>:<span class="number">45</span>:<span class="number">36</span></span><br><span class="line">testing element:<span class="number">41</span></span><br><span class="line">testing element:<span class="number">42</span></span><br><span class="line">testing element:<span class="number">43</span></span><br><span class="line">testing element:<span class="number">44</span></span><br><span class="line">testing element:<span class="number">45</span></span><br><span class="line">testing element:<span class="number">46</span></span><br><span class="line">testing element:<span class="number">47</span></span><br><span class="line">testing element:<span class="number">48</span></span><br><span class="line">testing element:<span class="number">49</span></span><br><span class="line">testing element:<span class="number">50</span></span><br><span class="line">projecting an element:<span class="number">50</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">50</span> at <span class="number">15</span>:<span class="number">45</span>:<span class="number">36</span></span><br></pre></td></tr></table></figure><p>当程序下次调用MoveNext()方法时，系统只会执行到能够产生下一项执行结果的地方。</p><p>上面的LINQ to Objects 改用为 PLINQ执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> answer = <span class="keyword">from</span> n <span class="keyword">in</span> ParallelEnumerable.Range(<span class="number">0</span>, <span class="number">300</span>)</span><br><span class="line">                         <span class="keyword">where</span> n.SomeTest()</span><br><span class="line">                         <span class="keyword">select</span> n.SomeProjection();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> iter = answer.GetEnumerator();</span><br><span class="line">            Console.WriteLine(<span class="string">"start iterating"</span>);</span><br><span class="line">            <span class="keyword">while</span> (iter.MoveNext()) </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"called MoveNext"</span>);</span><br><span class="line">                Console.WriteLine(iter.Current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SomeTest</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">int</span> inputValue</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"testing element:<span class="subst">&#123;inputValue&#125;</span>;当前线程：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span> inputValue % <span class="number">10</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">SomeProjection</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">int</span> input</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"projecting an element:<span class="subst">&#123;input&#125;</span>"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Delivered <span class="subst">&#123;input&#125;</span> at <span class="subst">&#123;DateTime.Now:T&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">截取部分结果说明：</span><br><span class="line">start iterating</span><br><span class="line">testing element:<span class="number">0</span>;当前线程：<span class="number">4</span></span><br><span class="line">testing element:<span class="number">150</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">75</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">225</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">226</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">227</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">228</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">229</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">230</span>;当前线程：<span class="number">6</span></span><br><span class="line">projecting an element:<span class="number">230</span></span><br><span class="line">projecting an element:<span class="number">0</span></span><br><span class="line">projecting an element:<span class="number">150</span></span><br><span class="line">testing element:<span class="number">76</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">77</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">78</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">79</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">80</span>;当前线程：<span class="number">3</span></span><br><span class="line">projecting an element:<span class="number">80</span></span><br><span class="line">testing element:<span class="number">151</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">152</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">153</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">154</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">155</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">156</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">157</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">158</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">159</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">160</span>;当前线程：<span class="number">5</span></span><br><span class="line">projecting an element:<span class="number">160</span></span><br><span class="line">testing element:<span class="number">161</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">162</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">231</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">232</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">233</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">234</span>;当前线程：<span class="number">6</span></span><br><span class="line">testing element:<span class="number">81</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">1</span>;当前线程：<span class="number">4</span></span><br><span class="line">testing element:<span class="number">163</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">235</span>;当前线程：<span class="number">6</span></span><br><span class="line">......</span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">230</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">testing element:<span class="number">223</span>;当前线程：<span class="number">5</span></span><br><span class="line">testing element:<span class="number">131</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">132</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">224</span>;当前线程：<span class="number">5</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">20</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">testing element:<span class="number">133</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">134</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">135</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">136</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">137</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">138</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">139</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">140</span>;当前线程：<span class="number">3</span></span><br><span class="line">called MoveNext</span><br><span class="line">projecting an element:<span class="number">140</span></span><br><span class="line">testing element:<span class="number">141</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">142</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">143</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">144</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">145</span>;当前线程：<span class="number">3</span></span><br><span class="line">Delivered <span class="number">150</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">240</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">30</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">160</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext                   出现了交叉情况</span><br><span class="line">testing element:<span class="number">146</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">147</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">148</span>;当前线程：<span class="number">3</span></span><br><span class="line">testing element:<span class="number">149</span>;当前线程：<span class="number">3</span></span><br><span class="line">Delivered <span class="number">250</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">40</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">80</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">170</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">260</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">50</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">90</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">180</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">270</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">60</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">100</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">190</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">280</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">70</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">110</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">200</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">290</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">120</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">210</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">130</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">220</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">called MoveNext</span><br><span class="line">Delivered <span class="number">140</span> at <span class="number">16</span>:<span class="number">05</span>:<span class="number">15</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>程序刚一调用MoveNext()方法，PLINQ马上启动多个线程来计算查询结果。</p><p>并行算法的并行程度可能会因为执行的操作受到影响，例如查询里有OrderBy、ThenBy方法，各个任务需要进行协调，还有Skip、SkipWhile、Take、TakeWhile方法也会影响并行程度。</p><p>如果想让PLINQ在计算结果时保留源数据的的顺序或者无序，可以通过AsOrdered和AsUnOrdered方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = (<span class="keyword">from</span> n <span class="keyword">in</span> ParallelEnumerable.Range(<span class="number">0</span>, <span class="number">300</span>).AsOrdered()</span><br><span class="line">                         <span class="keyword">where</span> n.SomeTest()</span><br><span class="line">                         <span class="keyword">select</span> n.SomeProjection()).Skip(<span class="number">10</span>).Take(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> answer1 = (<span class="keyword">from</span> n <span class="keyword">in</span> ParallelEnumerable.Range(<span class="number">0</span>, <span class="number">300</span>).AsUnordered()</span><br><span class="line">                          <span class="keyword">where</span> n.SomeTest()</span><br><span class="line">                          <span class="keyword">select</span> n.SomeProjection()).Skip(<span class="number">10</span>).Take(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>并行算法里如果有部分逻辑不能以并行方式执行，可以通过AsSequential()方法，将并行序列转换到IEnumerable。</p><p>即使使用了PLINQ，它也不一定会并行，只要当它认为会提供效率才会做出并行处理，如果想强制并行处理，可以使用<code>WithExecutionMode(ParallelExecutionMode.ForceParallelism)</code>。</p><p>PLINQ的并行线程数默认是根据当前计算机的处理器核心数，可以使用WithDegreeOfParallelism</p><p>方法设置并行度。</p><p>一般来说，PLINQ会把已经算出来的某些结果先放进缓冲区中，稍后公布给消费线程。可以使用</p><p>WithMergeOptions方式建议PLINQ使用其他缓冲方式。是建议，可能被PLINQ忽略。</p><p>即使有了PLINQ，但是并行算法依然不好设计，设计不好也不会提高效率。应该做的是寻找程序中的循环或者其他能够用并行方式来处理的任务，试着改用并行版本，再衡量效果。</p><h5 id="处理并行算法的异常"><a href="#处理并行算法的异常" class="headerlink" title="处理并行算法的异常"></a>处理并行算法的异常</h5><p>并行算法抛出的异常是由AggregateException包裹着。如果并行操作不止一项，AggregateException会嵌套。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">var</span> answer = (<span class="keyword">from</span> n <span class="keyword">in</span> ParallelEnumerable.Range(<span class="number">0</span>, <span class="number">300</span>)</span><br><span class="line">                             <span class="keyword">where</span> n.SomeTest()</span><br><span class="line">                             <span class="keyword">select</span> n.SomeProjection()).Skip(<span class="number">10</span>).Take(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">var</span> iter = answer.GetEnumerator();</span><br><span class="line">               Console.WriteLine(<span class="string">"start iterating"</span>);</span><br><span class="line">               <span class="keyword">while</span> (iter.MoveNext())</span><br><span class="line">               &#123;</span><br><span class="line">                   Console.WriteLine(<span class="string">"called MoveNext"</span>);</span><br><span class="line">                   Console.WriteLine(iter.Current);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span>(AggregateException ex)</span><br><span class="line">           &#123;</span><br><span class="line">               ReportAggregateException(ex); <span class="comment">//如果有多项并行操作，该递归，否则不递归也可以，递归的可以通用</span></span><br><span class="line">           &#125;</span><br><span class="line">                  </span><br><span class="line">       &#125;     </span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReportAggregateException</span>(<span class="params">AggregateException aggregateException</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">foreach</span>(<span class="keyword">var</span> exception <span class="keyword">in</span> aggregateException.InnerExceptions)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(exception <span class="keyword">is</span> AggregateException agEx)</span><br><span class="line">               &#123;</span><br><span class="line">                   ReportAggregateException(agEx);</span><br><span class="line">                   Console.WriteLine(<span class="string">"嵌套了"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   Console.WriteLine(exception.Message);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果希望有些异常想抛出给调用者，而有些异常当前方法处理掉就算了，可以用字典<code>Dictionary&lt;Type,Action&lt;Exception&gt;&gt;</code>，针对不同的异常，有不同的处理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> answer = (<span class="keyword">from</span> n <span class="keyword">in</span> ParallelEnumerable.Range(<span class="number">0</span>, <span class="number">300</span>)</span><br><span class="line">                              <span class="keyword">where</span> n.SomeTest()</span><br><span class="line">                              <span class="keyword">select</span> n.SomeProjection()).Skip(<span class="number">10</span>).Take(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> iter = answer.GetEnumerator();</span><br><span class="line">                Console.WriteLine(<span class="string">"start iterating"</span>);</span><br><span class="line">                <span class="keyword">while</span> (iter.MoveNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"called MoveNext"</span>);</span><br><span class="line">                    Console.WriteLine(iter.Current);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AggregateException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> handlers = <span class="keyword">new</span> Dictionary&lt;Type, Action&lt;Exception&gt;&gt;();</span><br><span class="line">                handlers.Add(<span class="keyword">typeof</span>(WebException), error =&gt; Console.WriteLine(error.Message));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!HandleAggregateError(ex, handlers))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">HandleAggregateError</span>(<span class="params">AggregateException error, Dictionary&lt;Type, Action&lt;Exception&gt;&gt; errorHandles</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> exception <span class="keyword">in</span> error.InnerExceptions)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">is</span> AggregateException agEx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!HandleAggregateError(agEx, errorHandles))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (errorHandles.ContainsKey(exception.GetType()))</span><br><span class="line">        &#123;</span><br><span class="line">            errorHandles[exception.GetType()](exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑详细一点的话，还可以在并行任务里面处理异常，至于哪些异常需要抛出去，哪些不需要，好好衡量。</p><h5 id="线程池优于创建新线程"><a href="#线程池优于创建新线程" class="headerlink" title="线程池优于创建新线程"></a>线程池优于创建新线程</h5><p>线程的数量等于目标计算机的CPU核心数，未必效率最高，还有其他资源争夺也会影响最佳线程数。</p><p>编写多线程代码时，如果可以并行，最好使用<a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl" target="_blank" rel="noopener">任务并行库</a>，让这个底层程序库管理线程池，它可以根据当前可供使用的系统资源来适当的启动任务。</p><p>关于性能：任务库&gt;单独创建线程池（线程可重复使用）&gt;单独创建线程（线程不能重复使用）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//第一种 Task.Run</span></span><br><span class="line"><span class="comment">//var tasks = new List&lt;Task&gt;();</span></span><br><span class="line"><span class="comment">//tasks.Add(Task.Run(() =&gt; &#123; &#125;));</span></span><br><span class="line"><span class="comment">//tasks.Add(Task.Run(() =&gt; &#123; &#125;));</span></span><br><span class="line"><span class="comment">//tasks.Add(Task.Run(() =&gt; &#123; &#125;));</span></span><br><span class="line"><span class="comment">//await Task.WhenAll(tasks);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> answer = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> threads = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (AutoResetEvent e = <span class="keyword">new</span> AutoResetEvent(<span class="literal">false</span>))</span><br><span class="line">&#123;                </span><br><span class="line">    <span class="comment">//第二种 线程池</span></span><br><span class="line">    <span class="comment">//System.Threading.ThreadPool.QueueUserWorkItem((e0) =&gt; &#123;  &#125;, "nn0");</span></span><br><span class="line">    <span class="comment">//System.Threading.ThreadPool.QueueUserWorkItem((e1) =&gt; &#123; &#125;, "nn1");</span></span><br><span class="line">    <span class="comment">//System.Threading.ThreadPool.QueueUserWorkItem((e2) =&gt; &#123; answer=e2.ToString(); e.Set(); &#125;, "nn2");</span></span><br><span class="line">    <span class="comment">//e.WaitOne();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新线程</span></span><br><span class="line">    System.Threading.Thread thread = <span class="keyword">new</span> Thread(() =&gt; &#123; &#125;);</span><br><span class="line">    thread.Start();</span><br><span class="line">    System.Threading.Thread thread1 = <span class="keyword">new</span> Thread(() =&gt; &#123; &#125;);</span><br><span class="line">    thread1.Start();</span><br><span class="line">    System.Threading.Thread thread2 = <span class="keyword">new</span> Thread(() =&gt; &#123; <span class="keyword">if</span> (Interlocked.Decrement(<span class="keyword">ref</span> threads) == <span class="number">0</span>) e.Set(); &#125;);</span><br><span class="line">    thread2.Start();</span><br><span class="line">    System.Threading.Thread thread3 = <span class="keyword">new</span> Thread(() =&gt; &#123; &#125;);</span><br><span class="line">    thread3.Start();</span><br><span class="line"></span><br><span class="line">    e.WaitOne();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BackgroundWorker"><a href="#BackgroundWorker" class="headerlink" title="BackgroundWorker"></a>BackgroundWorker</h5><h1 id="lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc221403(v=vs.95)?redirectedfrom=MSDN" target="_blank" rel="noopener">Microsoft BackgroundWorker</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/5906272.html" target="_blank" rel="noopener">BackgroundWorker详细使用举例</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           BackgroundWorker worker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line">           <span class="comment">//运行</span></span><br><span class="line">           worker.DoWork += (<span class="keyword">object</span> sender, DoWorkEventArgs e) =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               BackgroundWorker backgroundWorker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line">               <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)e.Argument; i++)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       backgroundWorker.ReportProgress(i / <span class="number">10</span>, <span class="string">"客官稍等片刻，正在加速运行..."</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   sum += i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           worker.WorkerReportsProgress = <span class="literal">true</span>; <span class="comment">//进度</span></span><br><span class="line">           worker.ProgressChanged += (<span class="keyword">object</span> sender, ProgressChangedEventArgs e) =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">$"当前进度：<span class="subst">&#123;e.ProgressPercentage&#125;</span>，<span class="subst">&#123; e.UserState.ToString()&#125;</span>"</span>);</span><br><span class="line">           &#125;;</span><br><span class="line">           worker.RunWorkerAsync(<span class="number">100</span>); <span class="comment">//开始运行</span></span><br><span class="line">           Console.ReadLine();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BackgroundWorker worker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line">    <span class="comment">//运行</span></span><br><span class="line">    worker.DoWork += (<span class="keyword">object</span> sender, DoWorkEventArgs e) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        BackgroundWorker backgroundWorker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)e.Argument; i++)</span><br><span class="line">        &#123;                    </span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">if</span> (worker.CancellationPending == <span class="literal">true</span>) <span class="comment">//取消判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)e.Argument; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    worker.WorkerSupportsCancellation = <span class="literal">true</span>;  <span class="comment">//支持取消</span></span><br><span class="line">    worker.RunWorkerAsync(<span class="number">100</span>); <span class="comment">//开始运行</span></span><br><span class="line">    worker.CancelAsync();  <span class="comment">//取消</span></span><br><span class="line">    Console.ReadLine();</span><br></pre></td></tr></table></figure><h5 id="WPF和Winform的跨线程调用"><a href="#WPF和Winform的跨线程调用" class="headerlink" title="WPF和Winform的跨线程调用"></a>WPF和Winform的跨线程调用</h5><p>同步的Invoke和异步的BeginInvoke、EndInvoke方法。</p><p>WPF通用跨线程静态类设计，使用Dispatcher判断线程。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">XAMLControlExtensions</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeIfNeed</span>(<span class="params"><span class="keyword">this</span> System.Windows.Threading.DispatcherObject dispatcherObject,</span></span></span><br><span class="line"><span class="function"><span class="params">           Action doit,System.Windows.Threading.DispatcherPriority priority</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">if</span>(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) </span><br><span class="line">           &#123;</span><br><span class="line">               dispatcherObject.Dispatcher.Invoke(priority, doit);<span class="comment">//同步</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               doit();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> InvokeIfNeed&lt;T&gt;(<span class="keyword">this</span> System.Windows.Threading.DispatcherObject dispatcherObject,</span><br><span class="line">           Action&lt;T&gt; action,T args,System.Windows.Threading.DispatcherPriority priority)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread)</span><br><span class="line">           &#123;</span><br><span class="line">               dispatcherObject.Dispatcher.Invoke(priority, action, args);<span class="comment">//同步，回到UI线程执行action</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               action(args);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Winform跨线程调用静态类设计、使用InvokeRequire判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ControlExtensions</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeIfNeed</span>(<span class="params"><span class="keyword">this</span> Control control,Action action</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">//???</span></span><br><span class="line">         <span class="keyword">if</span>(control.IsHandleCreated == <span class="literal">false</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             action();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(control.InvokeRequired)&#123;</span><br><span class="line">             control.Invoke(action);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             action();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> InvokeIfNeed&lt;T&gt;(<span class="keyword">this</span> Control control, Action&lt;T&gt; action,T args)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//???</span></span><br><span class="line">         <span class="keyword">if</span> (control.IsHandleCreated == <span class="literal">false</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             action(args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (control.InvokeRequired)</span><br><span class="line">         &#123;</span><br><span class="line">             control.Invoke(action,args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             action(args);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeAsync</span>(<span class="params"><span class="keyword">this</span> Control control,Action action</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">//异步</span></span><br><span class="line">         control.BeginInvoke(action);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> InvokeAsync&lt;T&gt;(<span class="keyword">this</span> Control control, Action&lt;T&gt; action,T args)</span><br><span class="line">     &#123;</span><br><span class="line">         control.BeginInvoke(action,args);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Winform通过InvokeRequired判断，如果控件已经创建，InvokeRequired判断会很迅速，如果控件还没完全创建好，会多花一点时间，但整个程序一个控件都还没创建成功，那InvokeRequired可能会返回错误值。</p><p>WPF通过Dispacher判断，已经对某些特殊情况做了优化，比Winform的要好。</p><p>Invoke方法，会像目标Control的消息队列投递消息，把delegate需要的内容放进去，放进去的参数是副本。当目标控件处理消息时，会处理整个队列的消息。Invoke方法会反复去查询结果。如果目标控件同时有BeginInvoke和Invoke消息，容易出问题。</p><p>WPF可以通过DispatcherPriority设置消息执行的优先级。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>b3f2daae1cafe377c3f97d64c485e331954f3821</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc221403(v=vs.95)?redirectedfrom=MSDN" target="_blank" rel="noopener">Microsoft BackgroundWorker</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/5906272.html" target="_blank" rel="noopener">BackgroundWorker详细使用举例</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           BackgroundWorker worker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line">           <span class="comment">//运行</span></span><br><span class="line">           worker.DoWork += (<span class="keyword">object</span> sender, DoWorkEventArgs e) =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               BackgroundWorker backgroundWorker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line">               <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)e.Argument; i++)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       backgroundWorker.ReportProgress(i / <span class="number">10</span>, <span class="string">"客官稍等片刻，正在加速运行..."</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   sum += i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           worker.WorkerReportsProgress = <span class="literal">true</span>; <span class="comment">//进度</span></span><br><span class="line">           worker.ProgressChanged += (<span class="keyword">object</span> sender, ProgressChangedEventArgs e) =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">$"当前进度：<span class="subst">&#123;e.ProgressPercentage&#125;</span>，<span class="subst">&#123; e.UserState.ToString()&#125;</span>"</span>);</span><br><span class="line">           &#125;;</span><br><span class="line">           worker.RunWorkerAsync(<span class="number">100</span>); <span class="comment">//开始运行</span></span><br><span class="line">           Console.ReadLine();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BackgroundWorker worker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line">    <span class="comment">//运行</span></span><br><span class="line">    worker.DoWork += (<span class="keyword">object</span> sender, DoWorkEventArgs e) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        BackgroundWorker backgroundWorker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)e.Argument; i++)</span><br><span class="line">        &#123;                    </span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">if</span> (worker.CancellationPending == <span class="literal">true</span>) <span class="comment">//取消判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)e.Argument; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    worker.WorkerSupportsCancellation = <span class="literal">true</span>;  <span class="comment">//支持取消</span></span><br><span class="line">    worker.RunWorkerAsync(<span class="number">100</span>); <span class="comment">//开始运行</span></span><br><span class="line">    worker.CancelAsync();  <span class="comment">//取消</span></span><br><span class="line">    Console.ReadLine();</span><br></pre></td></tr></table></figure><h5 id="WPF和Winform的跨线程调用-1"><a href="#WPF和Winform的跨线程调用-1" class="headerlink" title="WPF和Winform的跨线程调用"></a>WPF和Winform的跨线程调用</h5><p>同步的Invoke和异步的BeginInvoke、EndInvoke方法。</p><p>WPF通用跨线程静态类设计，使用Dispatcher判断线程。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">XAMLControlExtensions</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeIfNeed</span>(<span class="params"><span class="keyword">this</span> System.Windows.Threading.DispatcherObject dispatcherObject,</span></span></span><br><span class="line"><span class="function"><span class="params">           Action doit,System.Windows.Threading.DispatcherPriority priority</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">if</span>(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) </span><br><span class="line">           &#123;</span><br><span class="line">               dispatcherObject.Dispatcher.Invoke(priority, doit);<span class="comment">//同步</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               doit();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> InvokeIfNeed&lt;T&gt;(<span class="keyword">this</span> System.Windows.Threading.DispatcherObject dispatcherObject,</span><br><span class="line">           Action&lt;T&gt; action,T args,System.Windows.Threading.DispatcherPriority priority)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread)</span><br><span class="line">           &#123;</span><br><span class="line">               dispatcherObject.Dispatcher.Invoke(priority, action, args);<span class="comment">//同步，回到UI线程执行action</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               action(args);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Winform跨线程调用静态类设计、使用InvokeRequire判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ControlExtensions</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeIfNeed</span>(<span class="params"><span class="keyword">this</span> Control control,Action action</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">//???</span></span><br><span class="line">         <span class="keyword">if</span>(control.IsHandleCreated == <span class="literal">false</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             action();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(control.InvokeRequired)&#123;</span><br><span class="line">             control.Invoke(action);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             action();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> InvokeIfNeed&lt;T&gt;(<span class="keyword">this</span> Control control, Action&lt;T&gt; action,T args)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//???</span></span><br><span class="line">         <span class="keyword">if</span> (control.IsHandleCreated == <span class="literal">false</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             action(args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (control.InvokeRequired)</span><br><span class="line">         &#123;</span><br><span class="line">             control.Invoke(action,args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             action(args);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeAsync</span>(<span class="params"><span class="keyword">this</span> Control control,Action action</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">//异步</span></span><br><span class="line">         control.BeginInvoke(action);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> InvokeAsync&lt;T&gt;(<span class="keyword">this</span> Control control, Action&lt;T&gt; action,T args)</span><br><span class="line">     &#123;</span><br><span class="line">         control.BeginInvoke(action,args);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Winform通过InvokeRequired判断，如果控件已经创建，InvokeRequired判断会很迅速，如果控件还没完全创建好，会多花一点时间，但整个程序一个控件都还没创建成功，那InvokeRequired可能会返回错误值。</p><p>WPF通过Dispacher判断，已经对某些特殊情况做了优化，比Winform的要好。</p><p>Invoke方法，会像目标Control的消息队列投递消息，把delegate需要的内容放进去，放进去的参数是副本。当目标控件处理消息时，会处理整个队列的消息。Invoke方法会反复去查询结果。如果目标控件同时有BeginInvoke和Invoke消息，容易出问题。</p><p>WPF可以通过DispatcherPriority设置消息执行的优先级。</p><h5 id="首先考虑Lock方法实现同步"><a href="#首先考虑Lock方法实现同步" class="headerlink" title="首先考虑Lock方法实现同步"></a>首先考虑Lock方法实现同步</h5><p>多个线程共享同一份资源时，数据可能遭到破坏，一般可以考虑Lock方法同步，Lock方法是Monitor.Enter和Monitor.Exit的进一层封装。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> syncHandle = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> TotalValue</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">lock</span> (syncHandle)  <span class="comment">//只能锁引用类型</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> total;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>但是如果加锁的地方和解锁地方不在一块，那只能使用Monitor。</p><p>在一些大型系统中关键资源在多个线程上共享，可能会出现死锁，可以考虑改用Monitor.TryEnter方法，它可以在指定时间内尝试加锁，不会一直停留那里。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IncrementTotal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Monitor.TryEnter(syncHandle1, <span class="number">1000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    total++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Monitor.Exit(syncHandle1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写成通用类，可以using直接使用</span></span><br><span class="line">   public sealed class LockHolder&lt;T&gt; : IDisposable where T : class</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> T handle;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">bool</span> holdsLock;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LockHolder</span>(<span class="params">T handle,<span class="keyword">int</span> millisecondsTimeout</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">this</span>.handle = handle;</span><br><span class="line">                holdsLock = System.Threading.Monitor.TryEnter(handle, millisecondsTimeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">bool</span> LockSuccessful</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> holdsLock;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">if</span> (holdsLock)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.Threading.Monitor.Exit(handle);</span><br><span class="line">                &#125;</span><br><span class="line">                holdsLock = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;            </span><br><span class="line">      <span class="keyword">using</span> (LockHolder&lt;<span class="keyword">object</span>&gt; lockObject = <span class="keyword">new</span> LockHolder&lt;<span class="keyword">object</span>&gt;(syncHandle1,<span class="number">1000</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (lockObject.LockSuccessful)</span><br><span class="line">          &#123;</span><br><span class="line">              total++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简单点的原子操作可以使用InterLock封装的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    total = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单的原子操作</span></span><br><span class="line">    System.Threading.Interlocked.Increment(<span class="keyword">ref</span> total); <span class="comment">//递增</span></span><br><span class="line">    System.Threading.Interlocked.Decrement(<span class="keyword">ref</span> total); <span class="comment">//递减</span></span><br><span class="line">    System.Threading.Interlocked.Exchange(<span class="keyword">ref</span> total, <span class="number">90</span>); <span class="comment">//替换</span></span><br><span class="line">    System.Threading.Interlocked.CompareExchange(<span class="keyword">ref</span> total, <span class="number">20</span>, <span class="number">80</span>);<span class="comment">//相等则替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Monitor.Wait() ，暂时释放锁，阻塞当前线程，直到被唤醒 。Monitor.Pulse()唤醒等待的线程。</p><p>这两个方法主要用于争夺同一把锁的多个线程的锁的交互。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockMe</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">WaitPulse1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> LockMe lM;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaitPulse1</span>(<span class="params">LockMe l</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.lM = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CriticalSection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Monitor.Enter(<span class="keyword">this</span>.lM);</span><br><span class="line">            <span class="comment">//Enter the Critical Section</span></span><br><span class="line">            Console.WriteLine(<span class="string">$"WaitPulse1: 线程<span class="subst">&#123; Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Monitor.Wait(<span class="keyword">this</span>.lM);  <span class="comment">//暂时释放锁、阻塞 直到被唤醒</span></span><br><span class="line">                Console.WriteLine(<span class="string">$"WaitPulse1: 修改总数 <span class="subst">&#123;Program.total++&#125;</span> "</span> +</span><br><span class="line">                    <span class="string">$"线程 <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">                Monitor.Pulse(<span class="keyword">this</span>.lM); <span class="comment">//唤醒</span></span><br><span class="line">                Console.WriteLine(<span class="string">$"WaitPulse1: 干自己的事"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">"WaitPulse1: 退出线程 "</span></span><br><span class="line">                + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            Monitor.Exit(<span class="keyword">this</span>.lM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">WaitPulse2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> LockMe lM;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaitPulse2</span>(<span class="params">LockMe l</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.lM = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CriticalSection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Monitor.Enter(<span class="keyword">this</span>.lM);</span><br><span class="line">            <span class="comment">//Enter the Critical Section</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Monitor.Pulse(<span class="keyword">this</span>.lM); <span class="comment">//唤醒</span></span><br><span class="line">                Console.WriteLine(<span class="string">"WaitPulse2 干自己的事"</span>);</span><br><span class="line">                Monitor.Wait(<span class="keyword">this</span>.lM);</span><br><span class="line">                Console.WriteLine(<span class="string">"WaitPulse2: 修改总数 "</span></span><br><span class="line">                   + Program.total++</span><br><span class="line">                   + <span class="string">" 线程 "</span></span><br><span class="line">                   + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">"WaitPulse2: 退出线程 "</span></span><br><span class="line">                + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            Monitor.Exit(<span class="keyword">this</span>.lM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            LockMe l = <span class="keyword">new</span> LockMe();</span><br><span class="line"></span><br><span class="line">            WaitPulse1 e1 = <span class="keyword">new</span> WaitPulse1(l);</span><br><span class="line">            WaitPulse2 e2 = <span class="keyword">new</span> WaitPulse2(l);</span><br><span class="line"></span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(e1.CriticalSection));</span><br><span class="line">            t1.Start();</span><br><span class="line"></span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(e2.CriticalSection));</span><br><span class="line">            t2.Start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Wait till the user enters something</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">WaitPulse1: 线程<span class="number">3</span></span><br><span class="line">WaitPulse2 干自己的事</span><br><span class="line">WaitPulse1: 修改总数 <span class="number">0</span> 线程 <span class="number">3</span></span><br><span class="line">WaitPulse1: 干自己的事</span><br><span class="line">WaitPulse2: 修改总数 <span class="number">1</span> 线程 <span class="number">4</span></span><br><span class="line">WaitPulse2 干自己的事</span><br><span class="line">WaitPulse1: 修改总数 <span class="number">2</span> 线程 <span class="number">3</span></span><br><span class="line">WaitPulse1: 干自己的事</span><br><span class="line">WaitPulse2: 修改总数 <span class="number">3</span> 线程 <span class="number">4</span></span><br><span class="line">WaitPulse2 干自己的事</span><br><span class="line">WaitPulse1: 修改总数 <span class="number">4</span> 线程 <span class="number">3</span></span><br><span class="line">WaitPulse1: 干自己的事</span><br><span class="line">WaitPulse2: 修改总数 <span class="number">5</span> 线程 <span class="number">4</span></span><br><span class="line">WaitPulse2 干自己的事</span><br><span class="line">WaitPulse1: 修改总数 <span class="number">6</span> 线程 <span class="number">3</span></span><br><span class="line">WaitPulse1: 干自己的事</span><br><span class="line">WaitPulse2: 修改总数 <span class="number">7</span> 线程 <span class="number">4</span></span><br><span class="line">WaitPulse2 干自己的事</span><br><span class="line">WaitPulse1: 修改总数 <span class="number">8</span> 线程 <span class="number">3</span></span><br><span class="line">WaitPulse1: 干自己的事</span><br><span class="line">WaitPulse1: 退出线程 <span class="number">3</span></span><br><span class="line">WaitPulse2: 修改总数 <span class="number">9</span> 线程 <span class="number">4</span></span><br><span class="line">WaitPulse2: 退出线程 <span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="建锁原则"><a href="#建锁原则" class="headerlink" title="建锁原则"></a>建锁原则</h5><p>尽可能小范围、尽可能私有化、</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非静态锁举例</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">object</span> syncHandle; <span class="comment">//锁 私有化</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">object</span> <span class="title">GetSyncHandle</span>(<span class="params"></span>) <span class="comment">//私有</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//创建锁的时候避免其他线程闯入</span></span><br><span class="line">            System.Threading.Interlocked.CompareExchange(<span class="keyword">ref</span> syncHandle, <span class="keyword">new</span> Object(), <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> syncHandle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (GetSyncHandle())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="不建议在加锁区域调用未知方法"><a href="#不建议在加锁区域调用未知方法" class="headerlink" title="不建议在加锁区域调用未知方法"></a>不建议在加锁区域调用未知方法</h5><p>未知方法如果是在另外的线程执行，且需要当前区域的锁了的锁，会死锁，罕见奇特的死锁。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                WorkerClass workerClass = <span class="keyword">new</span> WorkerClass();</span><br><span class="line">                workerClass.RaiseProgress += RaiseProgress;</span><br><span class="line">                workerClass.DoWork();</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.Start();            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseProgress</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs eventArgs</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            WorkerClass workerClass = sender <span class="keyword">as</span> WorkerClass;</span><br><span class="line">            <span class="keyword">if</span> (workerClass != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Action action = () =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    button1.Text = workerClass.Progress.ToString(); <span class="comment">//UI线程 Progress要获取锁handle，</span></span><br><span class="line">                &#125;;</span><br><span class="line">                button1.Invoke(action);                               </span><br><span class="line">            &#125;s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WorkerClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;EventArgs&gt; RaiseProgress;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">object</span> syncHandle = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (syncHandle)  <span class="comment">//后台线程 锁住了handle</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">                    progress++;</span><br><span class="line">                    RaiseProgress?.Invoke(<span class="keyword">this</span>, EventArgs.Empty); <span class="comment">//死锁了，后台线程等UI线程执行完，UI线程又等后台线程的锁释放。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> progress;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> Progress</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">lock</span> (syncHandle)</span><br><span class="line">                        <span class="keyword">return</span> progress++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考书：《Effective C#》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录《Effective C#》学习过程。&lt;/p&gt;
&lt;h5 id=&quot;通过Parallel-LINQ-PLINQ-实现并行算法&quot;&gt;&lt;a href=&quot;#通过Parallel-LINQ-PLINQ-实现并行算法&quot; class=&quot;headerlink&quot; title=&quot;通过Paral
      
    
    </summary>
    
    
    
      <category term="PLINQ" scheme="http://huangbaishi.github.io/tags/PLINQ/"/>
    
  </entry>
  
  <entry>
    <title>学习链接记录</title>
    <link href="http://huangbaishi.github.io/2020/01/21/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://huangbaishi.github.io/2020/01/21/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%E8%AE%B0%E5%BD%95/</id>
    <published>2020-01-21T21:06:28.000Z</published>
    <updated>2020-02-14T17:03:38.028Z</updated>
    
    <content type="html"><![CDATA[<ul><li>C#概念 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/</a></li><li>Git Book <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">https://git-scm.com/book/en/v2</a></li><li>《Effective C#》第二版 <a href="https://wizardforcel.gitbooks.io/effective-csharp/" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/effective-csharp/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;C#概念 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://do
      
    
    </summary>
    
    
    
      <category term="C#" scheme="http://huangbaishi.github.io/tags/C/"/>
    
      <category term="Git" scheme="http://huangbaishi.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>基于任务的异步编程</title>
    <link href="http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/"/>
    <id>http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/</id>
    <published>2020-01-18T19:52:40.000Z</published>
    <updated>2020-02-14T17:03:38.028Z</updated>
    
    <content type="html"><![CDATA[<p>记录《Effective C#》学习过程。</p><h5 id="任务运行的几种方法"><a href="#任务运行的几种方法" class="headerlink" title="任务运行的几种方法"></a><strong>任务运行的几种方法</strong></h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.new方式实例化一个Task，需要通过Start方法启动</span></span><br><span class="line">         Task task = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">         &#123;               </span><br><span class="line">             Console.WriteLine(<span class="string">$"task1的线程ID为<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">         task.Start();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//2.Task.Factory.StartNew(Action action)创建和启动一个Task</span></span><br><span class="line">         Task task2 = Task.Factory.StartNew(() =&gt;</span><br><span class="line">           &#123;        </span><br><span class="line">               Console.WriteLine(<span class="string">$"task2的线程ID为<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//3.Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task</span></span><br><span class="line">         Task task3 = Task.Run(() =&gt;</span><br><span class="line">           &#123;                  </span><br><span class="line">               Console.WriteLine(<span class="string">$"task3的线程ID为<span class="subst">&#123; Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><h5 id="使用异步方法执行异步工作"><a href="#使用异步方法执行异步工作" class="headerlink" title="使用异步方法执行异步工作"></a><strong>使用异步方法执行异步工作</strong></h5><ul><li><p>对于调用异步方法的主调方法来说，只要异步方法已经返回，这里返回的是Task对象，它就可以继续往下执行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MainMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = TaskMethod(); <span class="comment">//调用的开始，异步方法就在跑了</span></span><br><span class="line"></span><br><span class="line">    TaskStatus taskStatus = task.Status; </span><br><span class="line">    <span class="comment">//任务的状态</span></span><br><span class="line">    <span class="comment">//Created = 0,</span></span><br><span class="line">    <span class="comment">//WaitingForActivation = 1,</span></span><br><span class="line">    <span class="comment">//WaitingToRun = 2,</span></span><br><span class="line">    <span class="comment">//Running = 3,</span></span><br><span class="line">    <span class="comment">//WaitingForChildrenToComplete = 4,</span></span><br><span class="line">    <span class="comment">//RanToCompletion = 5,</span></span><br><span class="line">    <span class="comment">//Canceled = 6,</span></span><br><span class="line">    <span class="comment">//Faulted = 7            </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sum = result + <span class="number">2000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">TaskMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = GetTask();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主调用方法执行到await的时候Task如果已经完成，就会返回一个已完成状态的Task对象，并且继续执行await的下一条语句，就像同步一样。</p></li><li><p>主调用方法执行到await的时候Task如果已经还未完成，底层的机制就是编译器把await后面的语句生成delegate，写入相应的状态信息。直到任务完成，会有一个SynchronizationContext类恢复delegate运行的情境到await之前的样子（控制台是没有SynchronizationContext的）。</p></li><li><p>一定要等候任务的执行结果，否则有异常也不会抛出来。</p></li><li><p>await后面的语句，可能是当前线程来做，也可能是另一条线程。</p></li><li><p>Task.Wait()、Task.Result可以做到等候Task执行完毕，才往下跑，但是会让当前线程阻塞。</p></li></ul><h5 id="不要写返回值类型为void的异步方法"><a href="#不要写返回值类型为void的异步方法" class="headerlink" title="不要写返回值类型为void的异步方法"></a><strong>不要写返回值类型为void的异步方法</strong></h5><ol><li>主调方法调用返回返回值为void的异步方法，如果异步方法执行报错，主调方法无法catch到它的异常。只能通过App.Domain.UnhandleException事件或其他非常规手段来处理异常。</li><li>通过AppDomain.UnhandleExceptioin事件处理异常并不能让程序从异常中恢复。</li><li>无法等待返回值为void的异步方法的执行结果，就无法轻易判断它什么时候执行完。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           Test();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//断点进不到catch</span></span><br><span class="line">       &#125;            </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为void的异步方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="keyword">var</span> task = GetTask();</span><br><span class="line">       <span class="keyword">var</span> result = <span class="keyword">await</span> task;            </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 应用程序的主入口点。</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   [<span class="meta">STAThread</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       Application.EnableVisualStyles();</span><br><span class="line">       Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">       AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;</span><br><span class="line"></span><br><span class="line">       Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentDomain_UnhandledException</span>(<span class="params"><span class="keyword">object</span> sender, UnhandledExceptionEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="comment">//断点可以进来</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="如果要写返回值为void的异步方法，一定要做好异常处理"><a href="#如果要写返回值为void的异步方法，一定要做好异常处理" class="headerlink" title="如果要写返回值为void的异步方法，一定要做好异常处理"></a><strong>如果要写返回值为void的异步方法，一定要做好异常处理</strong></h5><ol><li><p>第一种：简单的记录异常，不会妨碍程序继续往下执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = GetTask();</span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Log(ex.ToString()); <span class="comment">//伪代码            </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种：借助异常过滤器      </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;                        </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = GetTask();</span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)<span class="keyword">when</span>(LogMessage(ex)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1：如果LogMessage返回true，可以catch到异常,程序还能往下执行。</span></span><br><span class="line">        <span class="comment">//如果catch里面又抛出异常，另说。</span></span><br><span class="line">        <span class="comment">//2：第二如果LogMessage返回false，catch不到异常，会把异常重新抛出，</span></span><br><span class="line">        <span class="comment">//能在AppDomain.CurrentDomain.UnhandledException捕捉，整个程序会 //停掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">LogMessage</span>(<span class="params">Exception ex</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log(ex.ToString()); <span class="comment">//伪代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三种：把所执行的异步工作视为Task，处理异常的逻辑分别表示通用的<code>Action&lt;Exception&gt;</code>、<code>Func&lt;Exception,bool&gt;</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"><span class="keyword">this</span> Task task,Action&lt;Exception&gt; onErrors</span>)</span></span><br><span class="line"><span class="function"></span>&#123;                        </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        onErrors(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"><span class="keyword">this</span> Task task, Func&lt;Exception,<span class="keyword">bool</span>&gt; onErrors</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)<span class="keyword">when</span>(onErrors(ex))</span><br><span class="line">    &#123;</span><br><span class="line">        onErrors(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>假如希望有些异常能从中恢复</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> Test2&lt;TException&gt;(<span class="keyword">this</span> Task task, Action&lt;TException&gt; recovery,Func&lt;Exception,<span class="keyword">bool</span>&gt; onError) </span><br><span class="line">            <span class="keyword">where</span> TException : Exception</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> task;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)<span class="keyword">when</span>(onError(ex))  </span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(TException ex2) <span class="comment">//如果onError返回false，就有可能catch到TException,并从中恢复</span></span><br><span class="line">            &#123;</span><br><span class="line">                recovery(ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="不要同步方法与异步方法组合使用"><a href="#不要同步方法与异步方法组合使用" class="headerlink" title="不要同步方法与异步方法组合使用"></a><strong>不要同步方法与异步方法组合使用</strong></h5><p>第一种情况：同步方法里调用异步方法</p><ul><li>原因一：捕获异常麻烦，通过<code>Task.Wait()</code>或者<code>Task.Result</code>来等待Task执行完毕，系统所抛出的异常是非具体的，而是<code>AggregateException</code>类型异常。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task1 = GetTask1();</span><br><span class="line">        <span class="keyword">var</span> task2 = GetTask2();</span><br><span class="line">        <span class="keyword">var</span> result1 = task1.Result;</span><br><span class="line">        <span class="keyword">var</span> result2 = task2.Result;</span><br><span class="line">        <span class="keyword">return</span> result1 + result2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(AggregateException e)<span class="keyword">when</span>(e.InnerExceptions.FirstOrDefault().GetType()==<span class="keyword">typeof</span>(KeyNotFoundException))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原因二：代码如下，可能发生死锁，GUI及Asp.Net情境下的SynchronizationContext只包含一条线程。<code>Task.Wait()</code>会让这条线程阻塞，而await下面的语句又需要这条线程才能跑。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = Test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> a = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> b = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> c = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> d = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    _ = task.Result;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span> +</span><br><span class="line">                      <span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span> +</span><br><span class="line">                      <span class="string">"aaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">string</span> a = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> b = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> c = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> d = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Thread.Sleep相比，Task.Delay是一种异步的延时机制，允许线程去做其他事。</p><p>第二种情况：异步里启动另一个异步任务，并在另一个异步任务里执行计算量较大的同步操作。</p><p>原因一：本来就有线程执行这项异步操作，没必要需要开辟更多的线程执行。</p><p>原因二：异步方法开辟新的线程执行计算量较大的同步操作，误导开发调用者。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line">    <span class="comment">//调试得到 当前线程ID：1</span></span><br><span class="line">        <span class="keyword">await</span> GetTaskAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">ComputeValue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line">        <span class="comment">//调试得到 当前线程ID：4</span></span><br><span class="line">        <span class="keyword">double</span> finalAnswer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            finalAnswer += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalAnswer;</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">double</span>&gt; <span class="title">GetTaskAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="keyword">double</span>&gt;(()=&gt; &#123;                MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line"><span class="comment">//调试得到 当前线程ID：3</span></span><br><span class="line">            Task.Run(() =&gt; ComputeValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        task.Start();</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> task;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>异步任务嵌套异步任务是可以的，只是应该是将自己无法完成或者不便完成的任务交给另外的异步去做，而不是随意开辟新的线程，把本来就可以自己执行的工作转交出去。</p><h5 id="使用异步方法，要考虑线程分配和上下文切换的开销"><a href="#使用异步方法，要考虑线程分配和上下文切换的开销" class="headerlink" title="使用异步方法，要考虑线程分配和上下文切换的开销"></a><strong>使用异步方法，要考虑线程分配和上下文切换的开销</strong></h5><p>可以异步，但不要随便用。</p><p>原因一：线程成本，当前线程就能做好的工作转交给另一个线程做、前面线程的确减轻负担，但后面线程也增加负担了。所以在当前线程是稀缺且重要的资源，例如GUI应用程序的UI线程，才应该把计算量较大的工作转交给其他异步去做。</p><p>原因二：上下文切换成本，await任务之后，可以正常往下执行，是因为<code>SynchronizationContext</code>记住了await之前的所有状态。等任务执行完后，切换到原来的<code>SynchronizationContext</code>。</p><p>有些异步没有必要开辟新线程，例如<a href="https://docs.microsoft.com/en-us/dotnet/standard/io/asynchronous-file-i-o" target="_blank" rel="noopener">文件异步I/O</a>、<a href="https://docs.microsoft.com/en-us/dotnet/framework/network-programming/making-asynchronous-requests" target="_blank" rel="noopener">Web请求</a>，文件异步可以通过端口实现，Web请求可以通过网络中断实现。</p><h5 id="ConfigureAwait-false-方法使用"><a href="#ConfigureAwait-false-方法使用" class="headerlink" title="ConfigureAwait(false)方法使用"></a><strong>ConfigureAwait(false)方法使用</strong></h5><p>如果await语句之后的代码与上下文无关，可以通过调用Task对象的<code>ConfigureAwait(false)</code>告诉系统不必切回到原理捕获的上下文中运行,默认是true。</p><p>使用<code>ConfigureAwait(false)</code>好处是提高性能，避免死锁。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;       </span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync().ConfigureAwait(continueOnCapturedContext:<span class="literal">false</span>); <span class="comment">//一般不在应用程序级别代码使用false，这里只是举例子。</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//必须在特定的上下文中执行，如果上面设为false</span></span><br><span class="line">          <span class="comment">//抛异常 System.InvalidOperationException:“线程间操作无效:</span></span><br><span class="line">          <span class="comment">//从不是创建控件“button2”的线程访问它。”</span></span><br><span class="line">          <span class="comment">//button2.Text = "dddd"; </span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>如果是在某条await语句处调用ConfigureAwait(false)，而且这里await的任务是异步执行的，系统会把下面的代码安排到默认的上下文中去，一旦这样做，很难切回最初捕获的上下文。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;       </span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync().ConfigureAwait(continueOnCapturedContext:<span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync();</span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">string</span> aa = <span class="string">""</span>; <span class="comment">//在默认的上下文中执行，回不到第一个await之前捕获的上下文了。</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>但是可以通过调整代码结构，把与上下文无关的代码移到新的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnCommand</span>(<span class="params"><span class="keyword">object</span> sender,RoutedEventArgs e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> viewModel = DataContext <span class="keyword">as</span> SampleViewModel;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Config config = <span class="keyword">await</span> ReadConfigAsync(viewModel); </span><br><span class="line">        <span class="keyword">await</span> viewModel.Update(config); <span class="comment">//更新UI控件，需要在特定的上下文里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)<span class="keyword">when</span>(logMessage(viewModel,ex))&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要在特定的上下文中执行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;Config&gt; <span class="title">ReadConfigAsync</span>(<span class="params">SampleViewModel viewModel</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userInput = viewModel.webSite;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> DownloadAsync(userInput).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">var</span> items = XELement.Parse(result);</span><br><span class="line">    <span class="keyword">var</span> userConfig = <span class="keyword">from</span> node <span class="keyword">in</span> items.Descendants()</span><br><span class="line">        <span class="keyword">where</span> node.Name == <span class="string">"Config"</span></span><br><span class="line">        <span class="keyword">select</span> node.Value;</span><br><span class="line">    <span class="keyword">var</span> configUrl = userConfig.SingleOrDefault();</span><br><span class="line">    <span class="keyword">if</span>(configUrl != <span class="literal">null</span>)&#123;</span><br><span class="line">        result = <span class="keyword">await</span> DownloadAsync(configUrl).ConfigureAwait(<span class="literal">false</span>); <span class="comment">//虽然前面有了ConfigureAwait(false),但依然要写上</span></span><br><span class="line">        config = <span class="keyword">await</span> ParseConfig(result)</span><br><span class="line">            .ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        config = <span class="keyword">new</span> Config();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编写的是应用程序级代码，不要使用<code>ConfigureAwait(false)</code>，避免程序崩溃。详细阅读<a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" target="_blank" rel="noopener">ConfigureAwait常见问题解答</a></p><h5 id="Task对象"><a href="#Task对象" class="headerlink" title="Task对象"></a><strong>Task对象</strong></h5><p>Task对象只是执行异步的一个载体，它有几个重要的方法。<code>Task.WhenAll  Task.WhenAny</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> tasks = <span class="keyword">new</span> List&lt;Task&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//WhenAll 会根据现有的一批任务创建一个新任务</span></span><br><span class="line">            <span class="keyword">var</span> results = <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Task.whenAny返回的是最先执行完毕的那项任务</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> (<span class="keyword">await</span> Task.WhenAny(tasks));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">GetTask</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="keyword">int</span>&gt;(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            task.Start();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果有多项任务，而且要求必须对已经执行的每项任务的结果做一些处理，这些任务不会互相依赖。在考虑性能的情况下，当然想哪些先完成，哪些结果就先拿来处理，首先想到是用WhenAny方法，但是每一次WhenAny就创建一项新任务，效率不太好。这时可以考虑使用TaskCompletionSource,这是一个可以容纳异步任务执行结果的地方。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;T&gt;[] OrderByCompletion&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;Task&lt;T&gt;&gt; tasks)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">var</span> sourceTasks = tasks.ToList();</span><br><span class="line">          <span class="keyword">var</span> completionSources = <span class="keyword">new</span> TaskCompletionSource&lt;T&gt;[sourceTasks.Count];</span><br><span class="line">          <span class="keyword">var</span> outputTasks = <span class="keyword">new</span> Task&lt;T&gt;[completionSources.Length];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; completionSources.Length; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              completionSources[i] = <span class="keyword">new</span> TaskCompletionSource&lt;T&gt;();</span><br><span class="line">              outputTasks[i] = completionSources[i].Task;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> nextTaskIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//每项任务执行完后，然后执行的方法。</span></span><br><span class="line">          Action&lt;Task&lt;T&gt;&gt; continuation = completed =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//Interlocked.Increment确保线程安全</span></span><br><span class="line">              <span class="keyword">var</span> bucket = completionSources[Interlocked.Increment(<span class="keyword">ref</span> nextTaskIndex)];</span><br><span class="line">              bucket.TrySetResult(completed.Result);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">foreach</span>(<span class="keyword">var</span> inputTask <span class="keyword">in</span> sourceTasks)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//借用了委托，当任务完成后，在委托方法里处理任务结果</span></span><br><span class="line">              inputTask.ContinueWith(continuation, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously,</span><br><span class="line">                  TaskScheduler.Default);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> outputTasks;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 摘要:</span></span><br><span class="line">      <span class="comment">//     创建根据 continuationOptions 中指定的条件加以执行的延续任务。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 参数:</span></span><br><span class="line">      <span class="comment">//   continuationAction:</span></span><br><span class="line">      <span class="comment">//     根据在 continuationOptions 中指定的条件运行的操作。 在运行时，委托将作为一个自变量传递给完成的任务。       </span></span><br><span class="line">      <span class="comment">//   continuationOptions:</span></span><br><span class="line">      <span class="comment">//     用于设置计划延续任务的时间以及延续任务的工作方式的选项。       </span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Task <span class="title">ContinueWith</span>(<span class="params">Action&lt;Task&lt;TResult&gt;&gt; continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler</span>)</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Flags</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> TaskContinuationOptions</span><br><span class="line">  &#123;</span><br><span class="line">     ......</span><br><span class="line">     ......</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 摘要:</span></span><br><span class="line">      <span class="comment">//     指定应同步执行延续任务。 指定此选项后，延续任务在导致前面的任务转换为其最终状态的相同线程上运行。 如果在创建延续任务时已经完成前面的任务，则延续任务将在创建此延续任务的线程上运行。</span></span><br><span class="line">      <span class="comment">//     如果前面任务的 System.Threading.CancellationTokenSource 已在一个 finally（在 Visual Basic</span></span><br><span class="line">      <span class="comment">//     中为 Finally）块中释放，则使用此选项的延续任务将在该 finally 块中运行。 只应同步执行运行时间非常短的延续任务。 由于任务以同步方式执行，因此无需调用诸如</span></span><br><span class="line">      <span class="comment">//     System.Threading.Tasks.Task.Wait 的方法来确保调用线程等待任务完成。</span></span><br><span class="line">      ExecuteSynchronously = <span class="number">524288</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="考虑任务支持取消功能"><a href="#考虑任务支持取消功能" class="headerlink" title="考虑任务支持取消功能"></a><strong>考虑任务支持取消功能</strong></h5><p>可以通过CancellationToke这个struct类型实现任务的取消功能，如果调用者请求取消，则ThrowIfCancellationRequested()方法会抛出System.OperationCanceledException异常。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">RunPayroll</span>(<span class="params"></span>)</span> =&gt; RunPayroll(<span class="keyword">new</span> CancellationToken(), <span class="literal">null</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">RunPayroll</span>(<span class="params">CancellationToken cancellationToken</span>)</span> =&gt; RunPayroll(cancellationToken, <span class="literal">null</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">RunPayroll</span>(<span class="params">IProgress&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; progress</span>)</span> =&gt; RunPayroll(<span class="keyword">new</span> CancellationToken(), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">RunPayroll</span>(<span class="params">CancellationToken cancellationToken,IProgress&lt;<span class="keyword">int</span>,<span class="keyword">string</span>&gt; progress</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          progress?.Report(<span class="number">0</span>, <span class="string">"第一步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result0 = <span class="keyword">await</span> RunTask0();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">          progress?.Report(<span class="number">1</span>, <span class="string">"第二步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result1 = <span class="keyword">await</span> RunTask1();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">          progress?.Report(<span class="number">1</span>, <span class="string">"第三步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result2 = <span class="keyword">await</span> RunTask2();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">          progress?.Report(<span class="number">1</span>, <span class="string">"第四步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result3 = <span class="keyword">await</span> RunTask3();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 监控进度</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name="T"&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name="T1"&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">      public interface IProgress&lt;T, T1&gt;</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="function"><span class="keyword">void</span> <span class="title">Report</span>(<span class="params">T t, T1 t1</span>)</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>调用方可以通过CancellationTokenSource对象请求取消</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = RunPayroll(cts.Token);</span><br><span class="line">        cts.Cancel(); <span class="comment">//取消</span></span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(OperationCanceledException ex)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果异步任务方法的返回值是void，调用方无法遵循正常途径处理异常，只能通过专门的处理程序处理异常。因此，建议返回值为void的异步方法不支持取消功能。</p><h5 id="缓存异步方法的返回值"><a href="#缓存异步方法的返回值" class="headerlink" title="缓存异步方法的返回值"></a><strong>缓存异步方法的返回值</strong></h5><p>如果程序因为频繁分配Task对象而使得效率低下，可以考虑使用ValueTask优化。ValueTask提供了一个接受Task参数的构造函数，ValueTask是Struct类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ValueTask&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt; GetData(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt;(cacheData); <span class="comment">//从缓存中取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">async</span> Task&lt;IEnumerable&lt; <span class="keyword">int</span> &gt;&gt; load() <span class="comment">//内嵌异步方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> RunTask();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt;(load()); <span class="comment">//接受Task参数的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>千万确认性能瓶颈是因为内存分配的开销导致，再考虑把Task换成ValueTask，如果需要实时获取数据就没必要使用ValueTask。</p><p>参考书籍：《Effective C#》进阶篇，针对C# 7.0更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录《Effective C#》学习过程。&lt;/p&gt;
&lt;h5 id=&quot;任务运行的几种方法&quot;&gt;&lt;a href=&quot;#任务运行的几种方法&quot; class=&quot;headerlink&quot; title=&quot;任务运行的几种方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;任务运行的几种方法&lt;/strong&gt;&lt;/h5
      
    
    </summary>
    
    
      <category term="代码优化" scheme="http://huangbaishi.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="异步" scheme="http://huangbaishi.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Task" scheme="http://huangbaishi.github.io/tags/Task/"/>
    
  </entry>
  
</feed>
