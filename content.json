{"meta":{"title":"人生在勤，不索何获。","subtitle":"学海无涯~ 学海无涯~","description":"c#、dotnet等学习总结","author":"舒碧","url":"http://huangbaishi.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-01-20T21:19:45.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"categories/index.html","permalink":"http://huangbaishi.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-15T23:18:24.000Z","updated":"2020-02-14T17:03:38.028Z","comments":false,"path":"tags/index.html","permalink":"http://huangbaishi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"协变与逆变","slug":"协变与逆变","date":"2020-02-14T20:43:06.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"2020/02/14/协变与逆变/","link":"","permalink":"http://huangbaishi.github.io/2020/02/14/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/","excerpt":"","text":"记录 官方文档的协变与逆变学习过程。 使用举例协变与逆变能够实现数组类型、委托类型和泛型接口参数的隐式引用转换。 1、委托类型 123456789101112131415161718192021namespace ConsoleApp4&#123; class Program &#123; static void Main(string[] args) &#123; Func&lt;Bird&gt; birdFunc = () =&gt; new Bird(); Func&lt;Animal&gt; animalFunc = () =&gt; new Animal(); animalFunc = birdFunc; //协变 Func参数使用了out关键字 Animal animal = animalFunc(); Action&lt;Animal&gt; animalAction = (t) =&gt; &#123; &#125;; Action&lt;Bird&gt; birdAction = animalAction; //逆变 Action参数使用了in关键字 birdAction(new Bird()); &#125; &#125; class Animal &#123; &#125; class Bird : Animal &#123; &#125; &#125; 2、泛型接口和数组类型 1234567891011121314151617181920212223namespace ConsoleApp4&#123; class Program &#123; static void Main(string[] args) &#123; IEnumerable&lt;Bird&gt; birds = new List&lt;Bird&gt;() &#123; new Bird() &#123; &#125; &#125;; IEnumerable&lt;Animal&gt; animals = birds; //协变 IEnumerable&lt;out T&gt; var enumerators = animals.GetEnumerator(); enumerators.MoveNext(); Console.WriteLine(enumerators.Current.GetType().Name); //Bird Animal[] animalArray = new Bird[3]; animalArray[0] = new Bird(); Console.WriteLine(animalArray[0].GetType().Name); //Bird //System.ArrayTypeMismatchException:“Attempted to access an element as a type incompatible with the array.” animalArray[1] = new Animal(); &#125; &#125; class Animal &#123; &#125; class Bird : Animal &#123; &#125; &#125; 如果泛型接口或委托的泛型参数被声明为协变或逆变，该泛型接口或委托则被称为“变体”。 错误示范： 12345 List&lt;Object&gt; list = new List&lt;string&gt;(); //实现变体接口的类仍是固定类，这样是无法转换的。IEnumerable&lt;int&gt; integers = new List&lt;int&gt;(); IEnumerable&lt;Object&gt; objects = integers; //只能用于引用类型 创建变体泛型接口通过对泛型类型参数使用out关键字，将参数声明为协变。 123456789101112131415161718interface ICovariant&lt;out R&gt;&#123; R GetSomething(); void DoSomething(Action&lt;R&gt; callback); //逆变参数&#125; class Implementation&lt;R&gt; : ICovariant&lt;R&gt; &#123; public void DoSomething(Action&lt;R&gt; callback) &#123; throw new NotImplementedException(); &#125; public R GetSomething() &#123; throw new NotImplementedException(); &#125; &#125; 通过对泛型类型参数使用in关键字，将参数声明为逆变。 12345interface IContravariant&lt;in A&gt;&#123; void SetSomething(A sampleArg); void DoSomething&lt;T&gt;() where T : A; //逆变参数可以使用约束，协变不可以 &#125; 同一个接口，可以同时有逆变参数和协变参数，例如Func&lt;in T,out TResult&gt;。 派生变体泛型接口派生变体泛型接口，仍需使用in、out关键字来显示指定是否支持变体。 1234567891011interface ICovariant&lt;out R&gt;&#123; R GetSomething(); void DoSomething(Action&lt;R&gt; callback); //逆变参数&#125;interface IExtCovariant&lt;out R&gt; : ICovariant&lt;R&gt; //协变参数&#123;&#125;interface IExtCovariantOne&lt;R&gt; : ICovariant&lt;R&gt; //固定参数&#123;&#125; 如果父接口参数声明为逆变，则派生接口只能和父相同，或者声明为固定参数。","categories":[],"tags":[]},{"title":"C# Attribute","slug":"C# Attribute","date":"2020-02-09T19:24:51.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"2020/02/09/C# Attribute/","link":"","permalink":"http://huangbaishi.github.io/2020/02/09/C#%20Attribute/","excerpt":"","text":"记录C#特性学习过程。 使用举例1234[Serializable] //表示类可以序列化 public class SampleClass&#123; &#125; 12345678910111213 //https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.inattribute?view=netframework-4.8static void MethodA([In][Out] ref double x) &#123; &#125;static void MethodB([Out,In] double x) &#123;&#125;static void MethodB([Out] double x) &#123;&#125;//DllImport使用 https://www.cnblogs.com/xumingming/archive/2008/10/10/1308248.html[System.Runtime.InteropServices.DllImport(\"user32.dll\")]extern static void SampleMethod();[Conditional(\"DEBUG\"), Conditional(\"TEST1\")] //指示编译器，该特性可以指定多次void TraceMethod()&#123; &#125; 按照约定，特性名称以“Attribute”结尾。 不过，在代码中使用特性时，无需指定特性后缀。 显示标识特性、指定特性目标12345678910111213141516171819[type: Serializable] //表示类可以序列化 public class SampleClass&#123; &#125;[method: Conditional(\"DEBUG\"), Conditional(\"TEST1\")] //目标是方法。 指示编译器，该特性可以指定多次void TraceMethod()&#123; &#125;// default: applies to method[ValidatedContract]int Method1() &#123; return 0; &#125;// applies to method[method: ValidatedContract]int Method2() &#123; return 0; &#125;// applies to return value[return: ValidatedContract]int Method3() &#123; return 0; &#125; 自定义特性 1234567891011121314151617181920//限制特性目标类型 AttributeTargets//AllowMultiple 是否允许多次使用该特性[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = true)]public class AuthorAttribute : System.Attribute&#123; public string name; public double version; public AuthorAttribute(string name) &#123; this.name = name; version = 1.0; &#125;&#125;[Author(\"P. Ackerman\", version = 1.1)][Author(\"P. Betty\", version = 1.1)]class SampleClass&#123;&#125; AttributeUsageAttributeUsage是应用到自定义特性的特性。它有好几个参数，AttributeTargets：自定义特性可以有哪些特性目标，默认是全部；AllowMultiple：自定义的特性是否能在同一个特性目标上使用多次；Inherited:自定义特性是否可以有派生类继承或者重写成员继承。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849namespace ConsoleApp2&#123; class Program &#123; static void Main(string[] args) &#123; BaseClass baseClass = new BaseClass(); DerivedClass derivedClass = new DerivedClass(); var baseAttributes = baseClass.GetType().GetCustomAttributes(); var derivedAttributes = derivedClass.GetType().GetCustomAttributes(); Console.WriteLine(\"BaseClass Attributes:\"); foreach (var item in baseAttributes) &#123; Console.WriteLine(item); &#125; Console.WriteLine(\"DerivedClass Attributes:\"); foreach (var item in derivedAttributes) &#123; Console.WriteLine(item); &#125; &#125; &#125; [AttributeUsage(AttributeTargets.Class, Inherited = false)] class FirstAttribute : Attribute &#123; &#125; [AttributeUsage(AttributeTargets.Class)] //Inherited 默认值为true class SecondAttribute : Attribute &#123; &#125; [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] class ThirdAttribute : Attribute &#123; &#125; [AttributeUsage(AttributeTargets.All)] class FourthAttribute : Attribute &#123; &#125; [First, Second] class BaseClass &#123; [field:Fourth] [property:Fourth] public string name &#123; get; set; &#125; &#125; [Third, Third] class DerivedClass : BaseClass &#123; &#125;&#125; 通过反射访问特性对类型使用自定义特性，如果任何时候都不访问该特性信息，那特性就是多余的。可以通过反射获取自定义特性信息，主要方法是System.Attribute.GetCustomAttributes。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364namespace ConsoleApp2&#123; class Program &#123; static void Main(string[] args) &#123; TestAuthor.Test(); &#125; &#125; public class TestAuthor &#123; public static void Test() &#123; PrintAuthorInfo(typeof(FirstClass)); PrintAuthorInfo(typeof(SecondClass)); &#125; private static void PrintAuthorInfo(Type t) &#123; System.Console.WriteLine(\"Author information for &#123;0&#125;\", t); System.Attribute[] attrs = System.Attribute.GetCustomAttributes(t); foreach (System.Attribute attr in attrs) &#123; if (attr is AuthorAttribute author) &#123; System.Console.WriteLine(\"&#123;0&#125;, version &#123;1:f&#125;\", author.GetName(), author.version); &#125; &#125; &#125; &#125; //限制特性目标类型 AttributeTargets //AllowMultiple 是否允许多次使用该特性 [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = true)] public class AuthorAttribute : System.Attribute &#123; string name; public double version; public AuthorAttribute(string name) &#123; this.name = name; version = 1.0; &#125; public string GetName() &#123; return name; &#125; &#125; [Author(\"P. Ackerman\", version = 1.1)] [Author(\"P. Betty\", version = 1.2)] class FirstClass &#123; &#125; [Author(\"P. Betty\", version = 1.22)] class SecondClass &#123; &#125; 通用属性ObsoleteAttribute,标记不再使用的元素。使用该特性时，最好传入参数提示。该特性不能被继承。 123456789101112[System.Obsolete(\"use class B\")] //使用该方法，给予警告，但是不报错class A&#123; public void Method() &#123; &#125;&#125;class B&#123; //第二个参数error如果true，使用该方法则编译报错 [System.Obsolete(\"use NewMethod\", true)] public void OldMethod() &#123; &#125; public void NewMethod() &#123; &#125;&#125; ConditionalAttribute 使得方法是否执行依赖于预处理标识符。自定义的预处理标识符：项目-&gt;属性-&gt;生成-&gt;条件编译和符号。也可以使用#define预处理指令。 123456789101112131415161718192021222324252627282930namespace ConsoleApp4&#123; class Program &#123; static void Main(string[] args) &#123; DoIfAorB(); DoIfA(); //条件编译符号 有A和B才执行 &#125; [Conditional(\"A\"), Conditional(\"B\")] static void DoIfAorB() &#123; Console.WriteLine(\"DoIfAorB\"); &#125; [Conditional(\"A\")] static void DoIfA() &#123; DoIfAandB(); &#125; [Conditional(\"B\")] static void DoIfAandB() &#123; Console.WriteLine(\"DoIfA AND B\"); // Code to execute when both A and B are defined... &#125; &#125; &#125; ConditionalAttribute通常与DEBUG标识符一起使用。代替 #if DEBUG #endif … 1234567891011121314151617namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); CheckMethod(); &#125; [Conditional(\"DEBUG\")] public void CheckMethod() &#123; MessageBox.Show(\"debug\"); &#125; &#125;&#125; 调用方特性 CallerMemberName、CallerFilePath、CallerLineNumber ，都只能应用于参数，且参数必须有默认值。如果调用方没有传入值，则参数值是运行时得到的调用方信息。 1234567891011121314151617181920212223242526272829303132333435363738namespace ConsoleApp4&#123; class Program &#123; static void Main(string[] args) &#123; DoProcessing(); &#125; public static void DoProcessing() &#123; TraceMessage(\"Something happened.\"); TraceMessage(\"Something happened11.\",sourceFilePath:\"...path\"); &#125; public static void TraceMessage(string message, [System.Runtime.CompilerServices.CallerMemberName] string memberName = \"\", [System.Runtime.CompilerServices.CallerFilePath] string sourceFilePath = \"\", [System.Runtime.CompilerServices.CallerLineNumber] int sourceLineNumber = 0) &#123; System.Diagnostics.Trace.WriteLine(\"message: \" + message); System.Diagnostics.Trace.WriteLine(\"member name: \" + memberName); System.Diagnostics.Trace.WriteLine(\"source file path: \" + sourceFilePath); System.Diagnostics.Trace.WriteLine(\"source line number: \" + sourceLineNumber); &#125; &#125;&#125;输出结果:message: Something happened.member name: DoProcessingsource file path: C:\\Users\\bibi\\Desktop\\代码\\异步\\ConsoleApp4\\Program.cssource line number: 16message: Something happened11.member name: DoProcessingsource file path: ...pathsource line number: 17 程序集特性 AssemblyInfo.cs 文件放着程序集全局特性。分三种：唯一标识特性（例如：AssemblyVersionAttribute）、公司或产品信息特性（例如AssemblyCompanyAttribute）、程序集功能特性(例如：AssemblyTitleAttribute)。","categories":[],"tags":[{"name":"Attribute","slug":"Attribute","permalink":"http://huangbaishi.github.io/tags/Attribute/"}]},{"title":"动态编程","slug":"动态编程","date":"2020-02-04T16:54:23.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"2020/02/04/动态编程/","link":"","permalink":"http://huangbaishi.github.io/2020/02/04/%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/","excerpt":"","text":"记录《Effective C#》C#7.0 学习过程，但是用的是C#版本7.3验证书中例子,书中有些内容是对不上的。配置语言版本 动态编程的优缺点假如实现一通用加法，参数类型只要求支持特定的操作符，使用泛型是无法实现这种约束的，但动态类型就灵活很多了。 1234public static dynamic Add(dynamic a, dynamic b) //动态类型&#123; return a + b; //在运行时才会对类型进行解析。&#125; 但是运行时才对动态类型解析，因此问题也会延迟暴露。 连锁的动态类型，运算过程中如果有动态类型，那结果也是动态类型，要变成静态类型，只能自己转换类型。（缺 可能C#7.0以后可以自动转了，C#7.3可以自动转） 如果编码无法提前知道对象的类型，并且在运行时要调用某个特定的方法，可以考虑动态编程。其他情应使用lambda表达式或其他函数式编程实现。（建议） 1234567891011 public static void Main(string[] args) &#123; var lambdaAnswer = Add(3, 3, (a, b) =&gt; a + b); //传入lambda表达式1 var lambdaAnswer1 = Add(\"args\", 3, (a, b) =&gt; a + b.ToString());//传入lambda表达式2 var lambdaAnswer1 = Add(4, 3.4m, (a, b) =&gt; a + (int)b);//传入lambda表达式3 &#125; public static TResult Add&lt;T1,T2,TResult&gt;(T1 left,T2 right,Func&lt;T1,T2,TResult&gt; addMethod)&#123; return addMethod(left, right);&#125; 上面的表达式可以衍生出表达式树的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static class BinaryOperator&lt;T&gt; //如果操作数和运算结果同一类型，建议该写法&#123; static Func&lt;T,T,T&gt; compiledExpression; //缓存 public static T Add(T left, T right) &#123; if (compiledExpression == null) &#123; CreatFunc(); &#125; return compiledExpression(left, right); &#125; private static void CreatFunc() &#123; var leftOperand = Expression.Parameter(typeof(T), \"left\"); var rightOperand = Expression.Parameter(typeof(T), \"right\"); var body = Expression.Add(leftOperand, rightOperand); var adder = Expression.Lambda&lt;Func&lt;T,T,T&gt;&gt;(body, leftOperand, rightOperand); compiledExpression = adder.Compile(); &#125;&#125; public static class BinaryOperator&lt;T1, T2, TResult&gt; &#123; static Func&lt;T1, T2, TResult&gt; compiledExpression; public static TResult Add(T1 left,T2 right) &#123; if (compiledExpression == null) &#123; CreatFunc(); &#125; return compiledExpression(left, right); &#125; private static void CreatFunc() &#123; var leftOperand = Expression.Parameter(typeof(T1), \"left\"); var rightOperand = Expression.Parameter(typeof(T2), \"right\"); Expression convertedLeft = leftOperand; if (typeof(T1) != typeof(TResult)) &#123; convertedLeft = Expression.Convert(leftOperand, typeof(TResult)); //转换 &#125; Expression convertedRight = rightOperand; if (typeof(T2) != typeof(TResult)) &#123; convertedRight = Expression.Convert(rightOperand, typeof(TResult)); &#125; var body = Expression.Add(convertedLeft, convertedRight); var adder = Expression.Lambda&lt;Func&lt;T1, T2, TResult&gt;&gt;(body, leftOperand, rightOperand); compiledExpression = adder.Compile(); &#125; &#125; C#写出的动态程序（例如表达式树、dynamic…）都是在运行时做检查，效率是没有静态类型的快。 先静后动：通过接口或基类实现，lambda表达式，表达式树，动态类型。 动态编程技术可以帮助运行泛型参数的运行期类型的运用在System.Core程序集里，System.Linq.Enumerable.Cast&lt;T&gt;的扩展方法可以把序列中的每个元素转换成T类型，但是如果对T没有约束，Cast&lt;T&gt;方法只能认定T类型含有的那些System.Object的成员。 123456789101112131415161718192021222324252627282930313233343536373839 class Program &#123; public static void Main(string[] args) &#123; List&lt;string&gt; strList = new List&lt;string&gt;(); strList.Add(\"aa\"); strList.Add(\"bb\"); strList.Add(\"cc\"); var results = strList.Cast&lt;MyType&gt;(); //惰性 延迟转换 //和上面写法一个意思 //var results = from MyType v in strList //select v; try &#123; foreach(var item in results) &#123; Console.WriteLine(item); &#125; &#125; catch(InvalidCastException) //无效转换异常 &#123; Console.WriteLine(\"failed\"); &#125; &#125; &#125;//结果运行失败 public class MyType &#123; public string StringMember &#123; get; set; &#125; //不推荐设计Api时使用隐式转换器 public static implicit operator String(MyType aString) =&gt; aString.StringMember; public static implicit operator MyType(String aString) =&gt; new MyType &#123; StringMember = aString &#125;; &#125; 1234567891011121314public static void Main(string[] args)&#123; List&lt;string&gt; strList = new List&lt;string&gt;(); //是System.Object含有的那些成员，不会报无效转换异常。 strList.Add(\"aaa\"); var results = strList.Cast&lt;string&gt;(); foreach (var item in results) &#123; Console.WriteLine(item); &#125;&#125; 解决办法1： 12345var results = from MyType v in strList select v;换成var results = from v in strList select (MyType)v; //select方法接受的是lambda表达式，对于v来说，lambda表达式是string类型的对象 解决办法2：strList.Select(a =&gt; new MyType { StringMember = a }); 解决办法3：使用构造函数。 解决办法4：大量反射代码，知道拿到转换器，但是效率不如动态类型。 最后：动态类型 1234567891011121314/// &lt;summary&gt;/// 枚举扩展类/// &lt;/summary&gt;public static class EnumerableExtension&#123; public static IEnumerable&lt;TResult&gt; Convert&lt;TResult&gt;(this System.Collections.IEnumerable sequence) &#123; foreach(object item in sequence) &#123; dynamic result = (dynamic)item; yield return (TResult)result; //yield 迭代返回 &#125; &#125;&#125; 使用DynamicObject实现数据驱动的动态类型 直接继承DynamicObject，访问属性，会报动态绑定错误。 123456789101112public static void Main(string[] args)&#123; dynamic dynamicProperties = new DynamicPropertyBag(); try &#123; dynamicProperties.Date = DateTime.Now; &#125; catch(RuntimeBinderException ex) &#123; &#125; &#125; 于是，覆盖原来的TryGetMember、TrySetMember方法。 1234567891011121314151617181920212223242526272829class DynamicPropertyBag : DynamicObject&#123; private Dictionary&lt;string, object&gt; storage = new Dictionary&lt;string, object&gt;(); public override bool TryGetMember(GetMemberBinder binder, out object result) &#123; if (storage.ContainsKey(binder.Name)) &#123; result = storage[binder.Name]; return true; &#125; result = null; return false; &#125; public override bool TrySetMember(SetMemberBinder binder, object value) &#123; string key = binder.Name; if (storage.ContainsKey(key)) &#123; storage[key] = value; &#125; else &#123; storage.Add(key, value); &#125; return true; &#125;&#125; LINQ TO XML不是特别好用。如果想实现A元素.B元素[“C”,3]这样的链式，和两个同级索引获取值方法，可以覆盖DynamicObject的TryGetMember方法、TryGetIndex方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class DynamicXElement : DynamicObject&#123; private readonly XElement xmlSource; public DynamicXElement(XElement source) &#123; xmlSource = source; &#125; public override bool TryGetMember(GetMemberBinder binder, out object result) &#123; if (xmlSource == null) &#123; if (binder.Name == \"Value\") &#123; result = \"\"; &#125; else &#123; result = null; return false; &#125; &#125; else &#123; if (binder.Name == \"Value\") result = xmlSource.Value; else result = new DynamicXElement(xmlSource.Element(XName.Get(binder.Name))); &#125; return true; &#125; public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result) &#123; result = null; if (indexes.Length != 2) return false; if (!(indexes[0] is string)) return false; if (!(indexes[1] is int)) return false; if (xmlSource == null) return false; var allnodes = xmlSource.Elements(indexes[0].ToString()); var index = (int)indexes[1]; if (index &lt; allnodes.Count()) &#123; result = new DynamicXElement(allnodes.ElementAt(index)); return true; &#125; else &#123; result = null; return false; &#125; &#125;&#125; Expression APIWCF、Web服务等常针对某项服务生成对于的代理，如果服务器那边更新了方法，客户端代理需要相应的更新。但是使用Express API，就相对简单。 创建能够接受Expression的方法，把某套逻辑传入该方法，该方法对其进行解析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace ConsoleApp1&#123; //一个简单的例子：服务方法的参数是常量，打印方法名，参数类型，参数值。 class Program &#123; public static void Main(string[] args) &#123; var client = new ClientProxy&lt;IService&gt;(); client.CallInterface&lt;string&gt;(server=&gt;server.DoWork(666)); &#125; &#125; public class ClientProxy&lt;T&gt; &#123; public TResult CallInterface&lt;TResult&gt;(Expression&lt;Func&lt;T,TResult&gt;&gt; op) &#123; var exp = op.Body as MethodCallExpression; //静态方法或实例方法的调用 var methodName = exp.Method.Name; var methodInfo = exp.Method; var allParameters = from element in exp.Arguments select ProcessArgument(element); Console.WriteLine($\"Calling &#123;methodName&#125;\"); foreach(var param in allParameters) &#123; Console.WriteLine($\"\\tParameter type=&#123;param.ParamType&#125; value=&#123;param.ParamValue&#125;\"); &#125; //如何动态的传入参数 ？？？？？？？？？？？？？？？？？？？？？？ //???????????????????????????? //var result = op.Compile();// (()allParameters.First().ParamValue); return default(TResult); &#125; //处理的参数是个常量 private (Type ParamType,object ParamValue) ProcessArgument(Expression element) &#123; //通过先构造一个委托类型来创建一个 System.Linq.Expressions.LambdaExpression。 LambdaExpression expression = Expression.Lambda(Expression.Convert(element, element.Type)); //获取lambda返回的类型 Type paramType = expression.ReturnType; //动态调用当前委托表示的方法 var argument = expression.Compile().DynamicInvoke(); return (paramType, argument); &#125; &#125; public interface IService &#123; string DoWork(int number); &#125; public class ImplementService : IService &#123; public string DoWork(int number) &#123; return \"hello world\"; &#125; &#125;&#125; 动态的类型转换器，编写可以在运行期自动产生代码的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Program &#123; public static void Main(string[] args) &#123; var converter = new Converter&lt;Source,Dest&gt;(); Source source = new Source(); source.AA = \"AA\"; source.BB = 22; source.CC = 66; source.EE = 88; var dest = converter.ConvertFrom(source); &#125; &#125; public class Converter&lt;TSource, TDest&gt; &#123; Func&lt;TSource, TDest&gt; converter; public TDest ConvertFrom(TSource source) &#123; if (converter == null) &#123; CreateConverter(); &#125; return converter(source); &#125; private void CreateConverter() &#123; //创建一个ParameterExpression节点，标识表达式树中的参数或变量 var source = Expression.Parameter(typeof(TSource), \"source\"); //创建一个ParameterExpression节点，标识表达式树中的参数或变量 var dest = Expression.Variable(typeof(TDest), \"dest\"); var assignments = from srcProp in typeof(TSource). GetProperties(BindingFlags.Public | BindingFlags.Instance) where srcProp.CanRead let destProp = typeof(TDest).GetProperty(srcProp.Name, BindingFlags.Public | BindingFlags.Instance) where (destProp != null) &amp;&amp; (destProp.CanWrite) select Expression.Assign(Expression.Property(dest, destProp), Expression.Property(source, srcProp)); var body = new List&lt;Expression&gt;(); body.Add(Expression.Assign(dest,Expression.New(typeof(TDest)))); body.AddRange(assignments); body.Add(dest); var expr = Expression.Lambda&lt;Func&lt;TSource, TDest&gt;&gt;(Expression.Block(new[] &#123; dest&#125;,body.ToArray()),source); var func = expr.Compile(); converter = func; &#125; &#125; public class Source &#123; public string AA &#123; get; set; &#125; public int BB &#123; get; set; &#125; public double CC &#123; get; set; &#125; private double DD &#123; get; set; &#125; //无法赋值 public double EE &#123; get; set; &#125; //无法赋值 &#125; public class Dest &#123; public string AA &#123; get; set; &#125; public int BB &#123; get; set; &#125; public double CC &#123; get; set; &#125; private double DD &#123; get; set; &#125; public static double EE &#123; get; set; &#125; &#125; 每当想使用反射编程时候，首先应该考虑能不能改用效率更高的Expression API。 减少公有API中的动态对象动态对象具有传染性，建议API返回静态类型。 12dynamic a = \"\";var b = a + \"\"; //b是动态类型 动态对象在越小的范围使用越好。 1234567891011121314//第一种:不好的API,需要传入动态类型参数。 public static dynamic Add(dynamic a, dynamic b) //动态类型 &#123; return a + b; //在运行时才会对类型进行解析。 &#125;//改良 参数改为泛型，返回类型转为静态 public static TResult Add&lt;T1,T2,TResult&gt;(T1 t1,T2 t2) &#123; return (TResult)Add(t1, t2); dynamic Add(dynamic t11,dynamic t12) &#123; return t11 + t12; &#125; &#125; 有时候，确实需要把动态对象放到接口中，但不代表整个接口都是动态代码，只应该把要依赖动态对象才能运作的成员设计成动态的。 举例：https://github.com/JoshClose/CsvHelper ，CSV数据的读取器。 1: 建立一个文本文件，内容如下 1234列1 ,列2 , 列311 ,2222 ,3333 12 ,2223 ,3334 13 ,2224 ,3335 2: 这里的CSVRow虽然设计为内部私有类，但是TryGetMember是覆盖了父类的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace ConsoleApp1&#123; class Program &#123; public static void Main(string[] args) &#123; var data = new CSVDataContainer(new System.IO.StreamReader(@\"C:\\Users\\bibi\\Desktop\\代码\\异步\\ConsoleApp1\\TextFile1.txt\")); foreach(var item in data.Rows) &#123; Console.WriteLine($\"&#123;item.列1&#125; &#123;item.列2&#125; &#123;item.列3&#125;\"); &#125; dynamic a = \"\"; var b = a + \"\"; &#125; public static TResult Add&lt;T1,T2,TResult&gt;(T1 t1,T2 t2) &#123; return (TResult)Add(t1, t2); dynamic Add(dynamic t11,dynamic t12) &#123; return t11 + t12; &#125; &#125; &#125; public class CSVDataContainer &#123; private class CSVRow : DynamicObject &#123; private List&lt;(string, string)&gt; values = new List&lt;(string, string)&gt;(); public CSVRow(IEnumerable&lt;string&gt; headers,IEnumerable&lt;string&gt; items) &#123; values.AddRange(headers.Zip(items, (header, value) =&gt; (header, value))); &#125; //虽然CSVRow是私有，但这个依然可以覆盖。 public override bool TryGetMember(GetMemberBinder binder, out object result) &#123; var answer = values.FirstOrDefault(n =&gt; n.Item1 == binder.Name); result = answer.Item2; return result != null; &#125; &#125; private List&lt;string&gt; columnNames = new List&lt;string&gt;(); private List&lt;CSVRow&gt; data = new List&lt;CSVRow&gt;(); public CSVDataContainer(System.IO.TextReader stream) &#123; var headers = stream.ReadLine(); columnNames = (from header in headers.Split(',') select header.Trim()).ToList(); var line = stream.ReadLine(); while(line != null) &#123; var items = line.Split(','); data.Add(new CSVRow(columnNames, items)); line = stream.ReadLine(); &#125; &#125; public dynamic this[int index]=&gt;data[index]; public IEnumerable&lt;dynamic&gt; Rows =&gt; data; &#125;&#125;","categories":[],"tags":[{"name":"Dynamic","slug":"Dynamic","permalink":"http://huangbaishi.github.io/tags/Dynamic/"},{"name":"DynamicObject","slug":"DynamicObject","permalink":"http://huangbaishi.github.io/tags/DynamicObject/"},{"name":"Expression","slug":"Expression","permalink":"http://huangbaishi.github.io/tags/Expression/"},{"name":"LambdaExpression","slug":"LambdaExpression","permalink":"http://huangbaishi.github.io/tags/LambdaExpression/"}]},{"title":"并行处理","slug":"并行处理","date":"2020-01-30T13:03:58.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"2020/01/30/并行处理/","link":"","permalink":"http://huangbaishi.github.io/2020/01/30/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/","excerpt":"","text":"记录《Effective C#》学习过程。 通过Parallel LINQ (PLINQ) 实现并行算法通过使用PLINQ提供的方法，可以简单的写出发挥多核CPU优势的代码，也会有线程开销。 对数据源调用AsParallel()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; public static void MainMethod() &#123; var students = new List&lt;Student&gt;() &#123; new Student()&#123;Age=10 &#125;,new Student()&#123; Age=9&#125;,new Student()&#123; Age=9&#125;,new Student()&#123; Age=9&#125; new Student()&#123; Age=12&#125;&#125;; //linq to objects IEnumerable&lt;Student&gt; filterStudents = students.Where(m =&gt; m.Age &lt; 10). Select(n =&gt; SetStudent(n)); //对数据源做AsParallel处理 不涉及数据共享，元素顺序没有特定要求。 //public class ParallelQuery&lt;TSource&gt; : ParallelQuery, IEnumerable&lt;TSource&gt;, IEnumerable ParallelQuery&lt;Student&gt; filterStudents1 = students.AsParallel().Where(m =&gt; m.Age &lt; 10). Select(n =&gt; SetStudent(n)); //linq to sql var filterStudents2 = from m in students where m.Age &lt; 10 select SetStudent(m); var filterStudents3 = from m in students.AsParallel() where m.Age &lt; 10 select SetStudent(m); &#125; private static Student SetStudent(Student student) &#123; student.TeacherName = \"李楚刀\"; return student; &#125; &#125; internal class Student &#123; public int Age &#123; get; set; &#125; public string TeacherName &#123; get; set; &#125; &#125; 数据划分，当执行并行查询的时候，第一个步骤是划分数据，划分数据方式包括范围划分、区块划分、带状划分、哈希划分。PLINQ自动的使用适当的算法对数据进行分区，并行并行执行查询的各个部分，然后合并结果。数据并行模式和PLINQ。 并行执行任务的算法：pipelining、 stop and go、inverted enumeration 12345678910111213141516 //采用 stop &amp; go 算法 var filterStudents3 = (from m in students.AsParallel() where m.Age &lt; 10 select SetStudent(m)).ToList(); //采用 stop &amp; go 算法 var filterStudents4 = (from m in students.AsParallel() where m.Age &lt; 10 select SetStudent(m)).ToArray(); //采用 inverted enumeration 算法 var filterStudents5 = from m in students.AsParallel() where m.Age &lt; 10 select SetStudent(m);//一边计算结果 一边对已经计算出来的元素并行地操作 filterStudents5.ForAll(item =&gt; Console.WriteLine(item)); LINQ to Objects 是以懒性的方式对查询操作进行求值，只有真正用到查询结果某个值的时候，系统才会去生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107namespace ConsoleApp1&#123; class Program &#123; static void Main(string[] args) &#123; var answer = from n in Enumerable.Range(0, 300) where n.SomeTest() select n.SomeProjection(); var iter = answer.GetEnumerator(); Console.WriteLine(\"start iterating\"); while (iter.MoveNext()) &#123; Console.WriteLine(\"called MoveNext\"); Console.WriteLine(iter.Current); &#125; &#125; &#125; public static class Test &#123; public static bool SomeTest(this int inputValue) &#123; Console.WriteLine($\"testing element:&#123;inputValue&#125;\"); return inputValue % 10 == 0; &#125; public static string SomeProjection(this int input) &#123; Console.WriteLine($\"projecting an element:&#123;input&#125;\"); return $\"Delivered &#123;input&#125; at &#123;DateTime.Now:T&#125;\"; &#125; &#125;&#125;截取部分结果说明：start iteratingtesting element:0projecting an element:0called MoveNextDelivered 0 at 15:45:36testing element:1testing element:2testing element:3testing element:4testing element:5testing element:6testing element:7testing element:8testing element:9testing element:10projecting an element:10called MoveNextDelivered 10 at 15:45:36testing element:11 又去查询元素testing element:12testing element:13testing element:14testing element:15testing element:16testing element:17testing element:18testing element:19testing element:20projecting an element:20called MoveNextDelivered 20 at 15:45:36testing element:21testing element:22testing element:23testing element:24testing element:25testing element:26testing element:27testing element:28testing element:29testing element:30projecting an element:30called MoveNextDelivered 30 at 15:45:36testing element:31testing element:32testing element:33testing element:34testing element:35testing element:36testing element:37testing element:38testing element:39testing element:40projecting an element:40called MoveNextDelivered 40 at 15:45:36testing element:41testing element:42testing element:43testing element:44testing element:45testing element:46testing element:47testing element:48testing element:49testing element:50projecting an element:50called MoveNextDelivered 50 at 15:45:36 当程序下次调用MoveNext()方法时，系统只会执行到能够产生下一项执行结果的地方。 上面的LINQ to Objects 改用为 PLINQ执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158namespace ConsoleApp1&#123; class Program &#123; static void Main(string[] args) &#123; var answer = from n in ParallelEnumerable.Range(0, 300) where n.SomeTest() select n.SomeProjection(); var iter = answer.GetEnumerator(); Console.WriteLine(\"start iterating\"); while (iter.MoveNext()) &#123; Console.WriteLine(\"called MoveNext\"); Console.WriteLine(iter.Current); &#125; &#125; &#125; public static class Test &#123; public static bool SomeTest(this int inputValue) &#123; Console.WriteLine($\"testing element:&#123;inputValue&#125;;当前线程：&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); return inputValue % 10 == 0; &#125; public static string SomeProjection(this int input) &#123; Console.WriteLine($\"projecting an element:&#123;input&#125;\"); return $\"Delivered &#123;input&#125; at &#123;DateTime.Now:T&#125;\"; &#125; &#125;&#125;截取部分结果说明：start iteratingtesting element:0;当前线程：4testing element:150;当前线程：5testing element:75;当前线程：3testing element:225;当前线程：6testing element:226;当前线程：6testing element:227;当前线程：6testing element:228;当前线程：6testing element:229;当前线程：6testing element:230;当前线程：6projecting an element:230projecting an element:0projecting an element:150testing element:76;当前线程：3testing element:77;当前线程：3testing element:78;当前线程：3testing element:79;当前线程：3testing element:80;当前线程：3projecting an element:80testing element:151;当前线程：5testing element:152;当前线程：5testing element:153;当前线程：5testing element:154;当前线程：5testing element:155;当前线程：5testing element:156;当前线程：5testing element:157;当前线程：5testing element:158;当前线程：5testing element:159;当前线程：5testing element:160;当前线程：5projecting an element:160testing element:161;当前线程：5testing element:162;当前线程：5testing element:231;当前线程：6testing element:232;当前线程：6testing element:233;当前线程：6testing element:234;当前线程：6testing element:81;当前线程：3testing element:1;当前线程：4testing element:163;当前线程：5testing element:235;当前线程：6......called MoveNextDelivered 230 at 16:05:15testing element:223;当前线程：5testing element:131;当前线程：3testing element:132;当前线程：3testing element:224;当前线程：5called MoveNextDelivered 20 at 16:05:15testing element:133;当前线程：3testing element:134;当前线程：3testing element:135;当前线程：3testing element:136;当前线程：3testing element:137;当前线程：3testing element:138;当前线程：3testing element:139;当前线程：3testing element:140;当前线程：3called MoveNextprojecting an element:140testing element:141;当前线程：3testing element:142;当前线程：3testing element:143;当前线程：3testing element:144;当前线程：3testing element:145;当前线程：3Delivered 150 at 16:05:15called MoveNextDelivered 240 at 16:05:15called MoveNextDelivered 30 at 16:05:15called MoveNextDelivered 160 at 16:05:15called MoveNext 出现了交叉情况testing element:146;当前线程：3testing element:147;当前线程：3testing element:148;当前线程：3testing element:149;当前线程：3Delivered 250 at 16:05:15called MoveNextDelivered 40 at 16:05:15called MoveNextDelivered 80 at 16:05:15called MoveNextDelivered 170 at 16:05:15called MoveNextDelivered 260 at 16:05:15called MoveNextDelivered 50 at 16:05:15called MoveNextDelivered 90 at 16:05:15called MoveNextDelivered 180 at 16:05:15called MoveNextDelivered 270 at 16:05:15called MoveNextDelivered 60 at 16:05:15called MoveNextDelivered 100 at 16:05:15called MoveNextDelivered 190 at 16:05:15called MoveNextDelivered 280 at 16:05:15called MoveNextDelivered 70 at 16:05:15called MoveNextDelivered 110 at 16:05:15called MoveNextDelivered 200 at 16:05:15called MoveNextDelivered 290 at 16:05:15called MoveNextDelivered 120 at 16:05:15called MoveNextDelivered 210 at 16:05:15called MoveNextDelivered 130 at 16:05:15called MoveNextDelivered 220 at 16:05:15called MoveNextDelivered 140 at 16:05:15请按任意键继续. . . 程序刚一调用MoveNext()方法，PLINQ马上启动多个线程来计算查询结果。 并行算法的并行程度可能会因为执行的操作受到影响，例如查询里有OrderBy、ThenBy方法，各个任务需要进行协调，还有Skip、SkipWhile、Take、TakeWhile方法也会影响并行程度。 如果想让PLINQ在计算结果时保留源数据的的顺序或者无序，可以通过AsOrdered和AsUnOrdered方法 1234567var answer = (from n in ParallelEnumerable.Range(0, 300).AsOrdered() where n.SomeTest() select n.SomeProjection()).Skip(10).Take(20);var answer1 = (from n in ParallelEnumerable.Range(0, 300).AsUnordered() where n.SomeTest() select n.SomeProjection()).Skip(10).Take(20); 并行算法里如果有部分逻辑不能以并行方式执行，可以通过AsSequential()方法，将并行序列转换到IEnumerable。 即使使用了PLINQ，它也不一定会并行，只要当它认为会提供效率才会做出并行处理，如果想强制并行处理，可以使用WithExecutionMode(ParallelExecutionMode.ForceParallelism)。 PLINQ的并行线程数默认是根据当前计算机的处理器核心数，可以使用WithDegreeOfParallelism 方法设置并行度。 一般来说，PLINQ会把已经算出来的某些结果先放进缓冲区中，稍后公布给消费线程。可以使用 WithMergeOptions方式建议PLINQ使用其他缓冲方式。是建议，可能被PLINQ忽略。 即使有了PLINQ，但是并行算法依然不好设计，设计不好也不会提高效率。应该做的是寻找程序中的循环或者其他能够用并行方式来处理的任务，试着改用并行版本，再衡量效果。 处理并行算法的异常并行算法抛出的异常是由AggregateException包裹着。如果并行操作不止一项，AggregateException会嵌套。 1234567891011121314151617181920212223242526272829303132333435363738394041class Program &#123; static void Main(string[] args) &#123; try &#123; var answer = (from n in ParallelEnumerable.Range(0, 300) where n.SomeTest() select n.SomeProjection()).Skip(10).Take(20); var iter = answer.GetEnumerator(); Console.WriteLine(\"start iterating\"); while (iter.MoveNext()) &#123; Console.WriteLine(\"called MoveNext\"); Console.WriteLine(iter.Current); &#125; &#125; catch(AggregateException ex) &#123; ReportAggregateException(ex); //如果有多项并行操作，该递归，否则不递归也可以，递归的可以通用 &#125; &#125; private static void ReportAggregateException(AggregateException aggregateException) &#123; foreach(var exception in aggregateException.InnerExceptions) &#123; if(exception is AggregateException agEx) &#123; ReportAggregateException(agEx); Console.WriteLine(\"嵌套了\"); &#125; else &#123; Console.WriteLine(exception.Message); &#125; &#125; &#125; &#125; 如果希望有些异常想抛出给调用者，而有些异常当前方法处理掉就算了，可以用字典Dictionary&lt;Type,Action&lt;Exception&gt;&gt;，针对不同的异常，有不同的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static void Test()&#123; try &#123; var answer = (from n in ParallelEnumerable.Range(0, 300) where n.SomeTest() select n.SomeProjection()).Skip(10).Take(20); var iter = answer.GetEnumerator(); Console.WriteLine(\"start iterating\"); while (iter.MoveNext()) &#123; Console.WriteLine(\"called MoveNext\"); Console.WriteLine(iter.Current); &#125; &#125; catch (AggregateException ex) &#123; var handlers = new Dictionary&lt;Type, Action&lt;Exception&gt;&gt;(); handlers.Add(typeof(WebException), error =&gt; Console.WriteLine(error.Message)); if (!HandleAggregateError(ex, handlers)) &#123; throw; &#125; &#125;&#125;private static bool HandleAggregateError(AggregateException error, Dictionary&lt;Type, Action&lt;Exception&gt;&gt; errorHandles)&#123; foreach (var exception in error.InnerExceptions) &#123; if (exception is AggregateException agEx) &#123; if (!HandleAggregateError(agEx, errorHandles)) &#123; return false; &#125; else &#123; continue; &#125; &#125; else if (errorHandles.ContainsKey(exception.GetType())) &#123; errorHandles[exception.GetType()](exception); &#125; else &#123; return false; &#125; &#125; return true;&#125; 考虑详细一点的话，还可以在并行任务里面处理异常，至于哪些异常需要抛出去，哪些不需要，好好衡量。 线程池优于创建新线程线程的数量等于目标计算机的CPU核心数，未必效率最高，还有其他资源争夺也会影响最佳线程数。 编写多线程代码时，如果可以并行，最好使用任务并行库，让这个底层程序库管理线程池，它可以根据当前可供使用的系统资源来适当的启动任务。 关于性能：任务库&gt;单独创建线程池（线程可重复使用）&gt;单独创建线程（线程不能重复使用） 12345678910111213141516171819202122232425262728293031 //第一种 Task.Run//var tasks = new List&lt;Task&gt;();//tasks.Add(Task.Run(() =&gt; &#123; &#125;));//tasks.Add(Task.Run(() =&gt; &#123; &#125;));//tasks.Add(Task.Run(() =&gt; &#123; &#125;));//await Task.WhenAll(tasks);string answer = \"\";int threads = 4;using (AutoResetEvent e = new AutoResetEvent(false))&#123; //第二种 线程池 //System.Threading.ThreadPool.QueueUserWorkItem((e0) =&gt; &#123; &#125;, \"nn0\"); //System.Threading.ThreadPool.QueueUserWorkItem((e1) =&gt; &#123; &#125;, \"nn1\"); //System.Threading.ThreadPool.QueueUserWorkItem((e2) =&gt; &#123; answer=e2.ToString(); e.Set(); &#125;, \"nn2\"); //e.WaitOne(); //创建新线程 System.Threading.Thread thread = new Thread(() =&gt; &#123; &#125;); thread.Start(); System.Threading.Thread thread1 = new Thread(() =&gt; &#123; &#125;); thread1.Start(); System.Threading.Thread thread2 = new Thread(() =&gt; &#123; if (Interlocked.Decrement(ref threads) == 0) e.Set(); &#125;); thread2.Start(); System.Threading.Thread thread3 = new Thread(() =&gt; &#123; &#125;); thread3.Start(); e.WaitOne();&#125; BackgroundWorker&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADMicrosoft BackgroundWorker BackgroundWorker详细使用举例 12345678910111213141516171819202122232425static void Main(string[] args) &#123; BackgroundWorker worker = new BackgroundWorker(); //运行 worker.DoWork += (object sender, DoWorkEventArgs e) =&gt; &#123; BackgroundWorker backgroundWorker = sender as BackgroundWorker; int sum = 0; for (int i = 0; i &lt;= (int)e.Argument; i++) &#123; if (i % 10 == 0) &#123; backgroundWorker.ReportProgress(i / 10, \"客官稍等片刻，正在加速运行...\"); &#125; sum += i; &#125; &#125;; worker.WorkerReportsProgress = true; //进度 worker.ProgressChanged += (object sender, ProgressChangedEventArgs e) =&gt; &#123; Console.WriteLine($\"当前进度：&#123;e.ProgressPercentage&#125;，&#123; e.UserState.ToString()&#125;\"); &#125;; worker.RunWorkerAsync(100); //开始运行 Console.ReadLine(); &#125; 12345678910111213141516171819202122232425BackgroundWorker worker = new BackgroundWorker(); //运行 worker.DoWork += (object sender, DoWorkEventArgs e) =&gt; &#123; BackgroundWorker backgroundWorker = sender as BackgroundWorker; int sum = 0; for (int i = 0; i &lt;= (int)e.Argument; i++) &#123; sum += i; &#125; Thread.Sleep(3000); if (worker.CancellationPending == true) //取消判断 &#123; return; &#125; for (int i = 0; i &lt;= (int)e.Argument; i++) &#123; sum += i; &#125; &#125;; worker.WorkerSupportsCancellation = true; //支持取消 worker.RunWorkerAsync(100); //开始运行 worker.CancelAsync(); //取消 Console.ReadLine(); WPF和Winform的跨线程调用同步的Invoke和异步的BeginInvoke、EndInvoke方法。 WPF通用跨线程静态类设计，使用Dispatcher判断线程。 123456789101112131415161718192021222324252627public static class XAMLControlExtensions &#123; public static void InvokeIfNeed(this System.Windows.Threading.DispatcherObject dispatcherObject, Action doit,System.Windows.Threading.DispatcherPriority priority) &#123; if(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) &#123; dispatcherObject.Dispatcher.Invoke(priority, doit);//同步 &#125; else &#123; doit(); &#125; &#125; public static void InvokeIfNeed&lt;T&gt;(this System.Windows.Threading.DispatcherObject dispatcherObject, Action&lt;T&gt; action,T args,System.Windows.Threading.DispatcherPriority priority) &#123; if(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) &#123; dispatcherObject.Dispatcher.Invoke(priority, action, args);//同步，回到UI线程执行action &#125; else &#123; action(args); &#125; &#125; &#125; Winform跨线程调用静态类设计、使用InvokeRequire判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static class ControlExtensions &#123; public static void InvokeIfNeed(this Control control,Action action) &#123; //??? if(control.IsHandleCreated == false) &#123; action(); &#125; else if(control.InvokeRequired)&#123; control.Invoke(action); &#125; else &#123; action(); &#125; &#125; public static void InvokeIfNeed&lt;T&gt;(this Control control, Action&lt;T&gt; action,T args) &#123; //??? if (control.IsHandleCreated == false) &#123; action(args); &#125; else if (control.InvokeRequired) &#123; control.Invoke(action,args); &#125; else &#123; action(args); &#125; &#125; public static void InvokeAsync(this Control control,Action action) &#123; //异步 control.BeginInvoke(action); &#125; public static void InvokeAsync&lt;T&gt;(this Control control, Action&lt;T&gt; action,T args) &#123; control.BeginInvoke(action,args); &#125; &#125; Winform通过InvokeRequired判断，如果控件已经创建，InvokeRequired判断会很迅速，如果控件还没完全创建好，会多花一点时间，但整个程序一个控件都还没创建成功，那InvokeRequired可能会返回错误值。 WPF通过Dispacher判断，已经对某些特殊情况做了优化，比Winform的要好。 Invoke方法，会像目标Control的消息队列投递消息，把delegate需要的内容放进去，放进去的参数是副本。当目标控件处理消息时，会处理整个队列的消息。Invoke方法会反复去查询结果。如果目标控件同时有BeginInvoke和Invoke消息，容易出问题。 WPF可以通过DispatcherPriority设置消息执行的优先级。 b3f2daae1cafe377c3f97d64c485e331954f3821 Microsoft BackgroundWorker BackgroundWorker详细使用举例 12345678910111213141516171819202122232425static void Main(string[] args) &#123; BackgroundWorker worker = new BackgroundWorker(); //运行 worker.DoWork += (object sender, DoWorkEventArgs e) =&gt; &#123; BackgroundWorker backgroundWorker = sender as BackgroundWorker; int sum = 0; for (int i = 0; i &lt;= (int)e.Argument; i++) &#123; if (i % 10 == 0) &#123; backgroundWorker.ReportProgress(i / 10, \"客官稍等片刻，正在加速运行...\"); &#125; sum += i; &#125; &#125;; worker.WorkerReportsProgress = true; //进度 worker.ProgressChanged += (object sender, ProgressChangedEventArgs e) =&gt; &#123; Console.WriteLine($\"当前进度：&#123;e.ProgressPercentage&#125;，&#123; e.UserState.ToString()&#125;\"); &#125;; worker.RunWorkerAsync(100); //开始运行 Console.ReadLine(); &#125; 12345678910111213141516171819202122232425BackgroundWorker worker = new BackgroundWorker(); //运行 worker.DoWork += (object sender, DoWorkEventArgs e) =&gt; &#123; BackgroundWorker backgroundWorker = sender as BackgroundWorker; int sum = 0; for (int i = 0; i &lt;= (int)e.Argument; i++) &#123; sum += i; &#125; Thread.Sleep(3000); if (worker.CancellationPending == true) //取消判断 &#123; return; &#125; for (int i = 0; i &lt;= (int)e.Argument; i++) &#123; sum += i; &#125; &#125;; worker.WorkerSupportsCancellation = true; //支持取消 worker.RunWorkerAsync(100); //开始运行 worker.CancelAsync(); //取消 Console.ReadLine(); WPF和Winform的跨线程调用同步的Invoke和异步的BeginInvoke、EndInvoke方法。 WPF通用跨线程静态类设计，使用Dispatcher判断线程。 123456789101112131415161718192021222324252627public static class XAMLControlExtensions &#123; public static void InvokeIfNeed(this System.Windows.Threading.DispatcherObject dispatcherObject, Action doit,System.Windows.Threading.DispatcherPriority priority) &#123; if(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) &#123; dispatcherObject.Dispatcher.Invoke(priority, doit);//同步 &#125; else &#123; doit(); &#125; &#125; public static void InvokeIfNeed&lt;T&gt;(this System.Windows.Threading.DispatcherObject dispatcherObject, Action&lt;T&gt; action,T args,System.Windows.Threading.DispatcherPriority priority) &#123; if(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) &#123; dispatcherObject.Dispatcher.Invoke(priority, action, args);//同步，回到UI线程执行action &#125; else &#123; action(args); &#125; &#125; &#125; Winform跨线程调用静态类设计、使用InvokeRequire判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static class ControlExtensions &#123; public static void InvokeIfNeed(this Control control,Action action) &#123; //??? if(control.IsHandleCreated == false) &#123; action(); &#125; else if(control.InvokeRequired)&#123; control.Invoke(action); &#125; else &#123; action(); &#125; &#125; public static void InvokeIfNeed&lt;T&gt;(this Control control, Action&lt;T&gt; action,T args) &#123; //??? if (control.IsHandleCreated == false) &#123; action(args); &#125; else if (control.InvokeRequired) &#123; control.Invoke(action,args); &#125; else &#123; action(args); &#125; &#125; public static void InvokeAsync(this Control control,Action action) &#123; //异步 control.BeginInvoke(action); &#125; public static void InvokeAsync&lt;T&gt;(this Control control, Action&lt;T&gt; action,T args) &#123; control.BeginInvoke(action,args); &#125; &#125; Winform通过InvokeRequired判断，如果控件已经创建，InvokeRequired判断会很迅速，如果控件还没完全创建好，会多花一点时间，但整个程序一个控件都还没创建成功，那InvokeRequired可能会返回错误值。 WPF通过Dispacher判断，已经对某些特殊情况做了优化，比Winform的要好。 Invoke方法，会像目标Control的消息队列投递消息，把delegate需要的内容放进去，放进去的参数是副本。当目标控件处理消息时，会处理整个队列的消息。Invoke方法会反复去查询结果。如果目标控件同时有BeginInvoke和Invoke消息，容易出问题。 WPF可以通过DispatcherPriority设置消息执行的优先级。 首先考虑Lock方法实现同步多个线程共享同一份资源时，数据可能遭到破坏，一般可以考虑Lock方法同步，Lock方法是Monitor.Enter和Monitor.Exit的进一层封装。 1234567891011121314object syncHandle = new object(); int total = 0; public int TotalValue &#123; get &#123; lock (syncHandle) //只能锁引用类型 &#123; return total; &#125; &#125; &#125; 但是如果加锁的地方和解锁地方不在一块，那只能使用Monitor。 在一些大型系统中关键资源在多个线程上共享，可能会出现死锁，可以考虑改用Monitor.TryEnter方法，它可以在指定时间内尝试加锁，不会一直停留那里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 public void IncrementTotal() &#123; if (Monitor.TryEnter(syncHandle1, 1000)) &#123; try &#123; total++; &#125; finally &#123; Monitor.Exit(syncHandle1); &#125; &#125; &#125;//写成通用类，可以using直接使用 public sealed class LockHolder&lt;T&gt; : IDisposable where T : class &#123; private T handle; private bool holdsLock; public LockHolder(T handle,int millisecondsTimeout) &#123; this.handle = handle; holdsLock = System.Threading.Monitor.TryEnter(handle, millisecondsTimeout); &#125; public bool LockSuccessful &#123; get &#123; return holdsLock; &#125; &#125; public void Dispose() &#123; if (holdsLock) &#123; System.Threading.Monitor.Exit(handle); &#125; holdsLock = false; &#125; &#125; &#125;//调用者 public void Test() &#123; using (LockHolder&lt;object&gt; lockObject = new LockHolder&lt;object&gt;(syncHandle1,1000)) &#123; if (lockObject.LockSuccessful) &#123; total++; &#125; &#125; &#125; 简单点的原子操作可以使用InterLock封装的方法 12345678910public void Test()&#123; total = 20; //简单的原子操作 System.Threading.Interlocked.Increment(ref total); //递增 System.Threading.Interlocked.Decrement(ref total); //递减 System.Threading.Interlocked.Exchange(ref total, 90); //替换 System.Threading.Interlocked.CompareExchange(ref total, 20, 80);//相等则替换&#125; 关于Monitor.Wait() ，暂时释放锁，阻塞当前线程，直到被唤醒 。Monitor.Pulse()唤醒等待的线程。 这两个方法主要用于争夺同一把锁的多个线程的锁的交互。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118namespace ConsoleApp1&#123; public class LockMe &#123; &#125; class WaitPulse1 &#123; private LockMe lM; public WaitPulse1(LockMe l) &#123; this.lM = l; &#125; public void CriticalSection() &#123; Monitor.Enter(this.lM); //Enter the Critical Section Console.WriteLine($\"WaitPulse1: 线程&#123; Thread.CurrentThread.ManagedThreadId&#125;\"); for (int i = 1; i &lt;= 5; i++) &#123; Monitor.Wait(this.lM); //暂时释放锁、阻塞 直到被唤醒 Console.WriteLine($\"WaitPulse1: 修改总数 &#123;Program.total++&#125; \" + $\"线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;\"); Monitor.Pulse(this.lM); //唤醒 Console.WriteLine($\"WaitPulse1: 干自己的事\"); &#125; Console.WriteLine(\"WaitPulse1: 退出线程 \" + Thread.CurrentThread.ManagedThreadId); //释放锁 Monitor.Exit(this.lM); &#125; &#125; class WaitPulse2 &#123; private LockMe lM; public WaitPulse2(LockMe l) &#123; this.lM = l; &#125; public void CriticalSection() &#123; Monitor.Enter(this.lM); //Enter the Critical Section for (int i = 1; i &lt;= 5; i++) &#123; Monitor.Pulse(this.lM); //唤醒 Console.WriteLine(\"WaitPulse2 干自己的事\"); Monitor.Wait(this.lM); Console.WriteLine(\"WaitPulse2: 修改总数 \" + Program.total++ + \" 线程 \" + Thread.CurrentThread.ManagedThreadId); &#125; Console.WriteLine(\"WaitPulse2: 退出线程 \" + Thread.CurrentThread.ManagedThreadId); //释放锁 Monitor.Exit(this.lM); &#125; &#125; class Program &#123; public static int total = 0; public static void Main(string[] args) &#123; LockMe l = new LockMe(); WaitPulse1 e1 = new WaitPulse1(l); WaitPulse2 e2 = new WaitPulse2(l); Thread t1 = new Thread(new ThreadStart(e1.CriticalSection)); t1.Start(); Thread t2 = new Thread(new ThreadStart(e2.CriticalSection)); t2.Start(); //Wait till the user enters something Console.ReadLine(); &#125; &#125;&#125;//结果WaitPulse1: 线程3WaitPulse2 干自己的事WaitPulse1: 修改总数 0 线程 3WaitPulse1: 干自己的事WaitPulse2: 修改总数 1 线程 4WaitPulse2 干自己的事WaitPulse1: 修改总数 2 线程 3WaitPulse1: 干自己的事WaitPulse2: 修改总数 3 线程 4WaitPulse2 干自己的事WaitPulse1: 修改总数 4 线程 3WaitPulse1: 干自己的事WaitPulse2: 修改总数 5 线程 4WaitPulse2 干自己的事WaitPulse1: 修改总数 6 线程 3WaitPulse1: 干自己的事WaitPulse2: 修改总数 7 线程 4WaitPulse2 干自己的事WaitPulse1: 修改总数 8 线程 3WaitPulse1: 干自己的事WaitPulse1: 退出线程 3WaitPulse2: 修改总数 9 线程 4WaitPulse2: 退出线程 4 建锁原则尽可能小范围、尽可能私有化、 1234567891011121314151617181920//非静态锁举例 public class Test &#123; private object syncHandle; //锁 私有化 private object GetSyncHandle() //私有 &#123; //创建锁的时候避免其他线程闯入 System.Threading.Interlocked.CompareExchange(ref syncHandle, new Object(), null); return syncHandle; &#125; public void Method() &#123; lock (GetSyncHandle()) &#123; &#125; &#125; &#125; 不建议在加锁区域调用未知方法未知方法如果是在另外的线程执行，且需要当前区域的锁了的锁，会死锁，罕见奇特的死锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); var thread = new Thread(() =&gt; &#123; WorkerClass workerClass = new WorkerClass(); workerClass.RaiseProgress += RaiseProgress; workerClass.DoWork(); &#125;); thread.Start(); &#125; public void RaiseProgress(object sender, EventArgs eventArgs) &#123; WorkerClass workerClass = sender as WorkerClass; if (workerClass != null) &#123; Action action = () =&gt; &#123; button1.Text = workerClass.Progress.ToString(); //UI线程 Progress要获取锁handle， &#125;; button1.Invoke(action); &#125;s &#125; public class WorkerClass &#123; public event EventHandler&lt;EventArgs&gt; RaiseProgress; private object syncHandle = new object(); public void DoWork() &#123; lock (syncHandle) //后台线程 锁住了handle &#123; System.Threading.Thread.Sleep(1000); progress++; RaiseProgress?.Invoke(this, EventArgs.Empty); //死锁了，后台线程等UI线程执行完，UI线程又等后台线程的锁释放。 &#125; &#125; private int progress; public int Progress &#123; get &#123; lock (syncHandle) return progress++; &#125; &#125; &#125; &#125; 参考书：《Effective C#》","categories":[],"tags":[{"name":"PLINQ","slug":"PLINQ","permalink":"http://huangbaishi.github.io/tags/PLINQ/"}]},{"title":"学习链接记录","slug":"学习链接记录","date":"2020-01-21T21:06:28.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"2020/01/21/学习链接记录/","link":"","permalink":"http://huangbaishi.github.io/2020/01/21/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%E8%AE%B0%E5%BD%95/","excerpt":"","text":"C#概念 https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/ Git Book https://git-scm.com/book/en/v2 《Effective C#》第二版 https://wizardforcel.gitbooks.io/effective-csharp/","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://huangbaishi.github.io/tags/C/"},{"name":"Git","slug":"Git","permalink":"http://huangbaishi.github.io/tags/Git/"}]},{"title":"基于任务的异步编程","slug":"使用异步方法执行异步工作","date":"2020-01-18T19:52:40.000Z","updated":"2020-02-14T17:03:38.028Z","comments":true,"path":"2020/01/18/使用异步方法执行异步工作/","link":"","permalink":"http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"记录《Effective C#》学习过程。 任务运行的几种方法123456789101112131415161718//1.new方式实例化一个Task，需要通过Start方法启动 Task task = new Task(() =&gt; &#123; Console.WriteLine($\"task1的线程ID为&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;); task.Start(); //2.Task.Factory.StartNew(Action action)创建和启动一个Task Task task2 = Task.Factory.StartNew(() =&gt; &#123; Console.WriteLine($\"task2的线程ID为&#123;Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;); //3.Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task Task task3 = Task.Run(() =&gt; &#123; Console.WriteLine($\"task3的线程ID为&#123; Thread.CurrentThread.ManagedThreadId&#125;\"); &#125;); 使用异步方法执行异步工作 对于调用异步方法的主调方法来说，只要异步方法已经返回，这里返回的是Task对象，它就可以继续往下执行。 123456789101112131415161718192021222324252627282930public static async void MainMethod()&#123; var task = TaskMethod(); //调用的开始，异步方法就在跑了 TaskStatus taskStatus = task.Status; //任务的状态 //Created = 0, //WaitingForActivation = 1, //WaitingToRun = 2, //Running = 3, //WaitingForChildrenToComplete = 4, //RanToCompletion = 5, //Canceled = 6, //Faulted = 7 var a = \"\"; var b = \"\"; var c = \"\"; var d = \"\"; var result = await task; var sum = result + 2000;&#125;public static async Task&lt;int&gt; TaskMethod()&#123; var task = GetTask(); return await task;&#125; 主调用方法执行到await的时候Task如果已经完成，就会返回一个已完成状态的Task对象，并且继续执行await的下一条语句，就像同步一样。 主调用方法执行到await的时候Task如果已经还未完成，底层的机制就是编译器把await后面的语句生成delegate，写入相应的状态信息。直到任务完成，会有一个SynchronizationContext类恢复delegate运行的情境到await之前的样子（控制台是没有SynchronizationContext的）。 一定要等候任务的执行结果，否则有异常也不会抛出来。 await后面的语句，可能是当前线程来做，也可能是另一条线程。 Task.Wait()、Task.Result可以做到等候Task执行完毕，才往下跑，但是会让当前线程阻塞。 不要写返回值类型为void的异步方法 主调方法调用返回返回值为void的异步方法，如果异步方法执行报错，主调方法无法catch到它的异常。只能通过App.Domain.UnhandleException事件或其他非常规手段来处理异常。 通过AppDomain.UnhandleExceptioin事件处理异常并不能让程序从异常中恢复。 无法等待返回值为void的异步方法的执行结果，就无法轻易判断它什么时候执行完。 1234567891011121314151617181920212223242526272829303132333435363738 private async void Button1_Click(object sender, EventArgs e) &#123; try &#123; Test(); &#125; catch(Exception ex) &#123; //断点进不到catch &#125; &#125; //返回值为void的异步方法 static async void Test() &#123; var task = GetTask(); var result = await task; &#125; /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main() &#123; Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException; Application.Run(new Form1()); &#125; private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) &#123; //断点可以进来 throw new NotImplementedException(); &#125; 如果要写返回值为void的异步方法，一定要做好异常处理 第一种：简单的记录异常，不会妨碍程序继续往下执行 123456789101112static async void Test1()&#123; try &#123; var task = GetTask(); await task; &#125; catch (Exception ex) &#123; Log(ex.ToString()); //伪代码 &#125;&#125; 第二种：借助异常过滤器 123456789101112131415161718192021static async void Test1()&#123; try &#123; var task = GetTask(); await task; &#125; catch(Exception ex)when(LogMessage(ex)) &#123; //1：如果LogMessage返回true，可以catch到异常,程序还能往下执行。 //如果catch里面又抛出异常，另说。 //2：第二如果LogMessage返回false，catch不到异常，会把异常重新抛出， //能在AppDomain.CurrentDomain.UnhandledException捕捉，整个程序会 //停掉 &#125;&#125;static bool LogMessage(Exception ex)&#123; Log(ex.ToString()); //伪代码 return false;&#125; 第三种：把所执行的异步工作视为Task，处理异常的逻辑分别表示通用的Action&lt;Exception&gt;、Func&lt;Exception,bool&gt; 12345678910111213141516171819202122static async void Test1(this Task task,Action&lt;Exception&gt; onErrors)&#123; try &#123; await task; &#125; catch(Exception ex) &#123; onErrors(ex); &#125;&#125;static async void Test2(this Task task, Func&lt;Exception,bool&gt; onErrors)&#123; try &#123; await task; &#125; catch (Exception ex)when(onErrors(ex)) &#123; onErrors(ex); &#125;&#125; 假如希望有些异常能从中恢复 12345678910111213141516static async void Test2&lt;TException&gt;(this Task task, Action&lt;TException&gt; recovery,Func&lt;Exception,bool&gt; onError) where TException : Exception &#123; try &#123; await task; &#125; catch (Exception ex)when(onError(ex)) &#123; &#125; catch(TException ex2) //如果onError返回false，就有可能catch到TException,并从中恢复 &#123; recovery(ex2); &#125; &#125; 不要同步方法与异步方法组合使用第一种情况：同步方法里调用异步方法 原因一：捕获异常麻烦，通过Task.Wait()或者Task.Result来等待Task执行完毕，系统所抛出的异常是非具体的，而是AggregateException类型异常。 123456789101112131415public static int GetSum()&#123; try &#123; var task1 = GetTask1(); var task2 = GetTask2(); var result1 = task1.Result; var result2 = task2.Result; return result1 + result2; &#125; catch(AggregateException e)when(e.InnerExceptions.FirstOrDefault().GetType()==typeof(KeyNotFoundException)) &#123; return 0; &#125;&#125; 原因二：代码如下，可能发生死锁，GUI及Asp.Net情境下的SynchronizationContext只包含一条线程。Task.Wait()会让这条线程阻塞，而await下面的语句又需要这条线程才能跑。 12345678910111213141516171819202122232425private async void Button1_Click(object sender, EventArgs e)&#123; var task = Test(); string a = \"\"; string b = \"\"; string c = \"\"; string d = \"\"; _ = task.Result; Console.WriteLine(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" + \"aaaaaaaaaaaaaaaaaaaaaa\");&#125;static async Task&lt;bool&gt; Test()&#123; await Task.Delay(2000); string a = \"\"; string b = \"\"; string c = \"\"; string d = \"\"; return true;&#125; 与Thread.Sleep相比，Task.Delay是一种异步的延时机制，允许线程去做其他事。 第二种情况：异步里启动另一个异步任务，并在另一个异步任务里执行计算量较大的同步操作。 原因一：本来就有线程执行这项异步操作，没必要需要开辟更多的线程执行。 原因二：异步方法开辟新的线程执行计算量较大的同步操作，误导开发调用者。 12345678910111213141516171819202122232425262728293031 private async void Button1_Click(object sender, EventArgs e) &#123; MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString()); //调试得到 当前线程ID：1 await GetTaskAsync(); &#125; public double ComputeValue() &#123; MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString()); //调试得到 当前线程ID：4 double finalAnswer = 0; for (int i = 0; i &lt; 100000000; i++) &#123; finalAnswer += i; &#125; return finalAnswer; &#125; public async Task&lt;double&gt; GetTaskAsync() &#123; var task = new Task&lt;double&gt;(()=&gt; &#123; MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());//调试得到 当前线程ID：3 Task.Run(() =&gt; ComputeValue()); return 2; &#125;); task.Start(); var result = await task; return result; &#125; 异步任务嵌套异步任务是可以的，只是应该是将自己无法完成或者不便完成的任务交给另外的异步去做，而不是随意开辟新的线程，把本来就可以自己执行的工作转交出去。 使用异步方法，要考虑线程分配和上下文切换的开销可以异步，但不要随便用。 原因一：线程成本，当前线程就能做好的工作转交给另一个线程做、前面线程的确减轻负担，但后面线程也增加负担了。所以在当前线程是稀缺且重要的资源，例如GUI应用程序的UI线程，才应该把计算量较大的工作转交给其他异步去做。 原因二：上下文切换成本，await任务之后，可以正常往下执行，是因为SynchronizationContext记住了await之前的所有状态。等任务执行完后，切换到原来的SynchronizationContext。 有些异步没有必要开辟新线程，例如文件异步I/O、Web请求，文件异步可以通过端口实现，Web请求可以通过网络中断实现。 ConfigureAwait(false)方法使用如果await语句之后的代码与上下文无关，可以通过调用Task对象的ConfigureAwait(false)告诉系统不必切回到原理捕获的上下文中运行,默认是true。 使用ConfigureAwait(false)好处是提高性能，避免死锁。 123456789private async void Button1_Click(object sender, EventArgs e) &#123; await GetTaskAsync().ConfigureAwait(continueOnCapturedContext:false); //一般不在应用程序级别代码使用false，这里只是举例子。 //必须在特定的上下文中执行，如果上面设为false //抛异常 System.InvalidOperationException:“线程间操作无效: //从不是创建控件“button2”的线程访问它。” //button2.Text = \"dddd\"; &#125; 如果是在某条await语句处调用ConfigureAwait(false)，而且这里await的任务是异步执行的，系统会把下面的代码安排到默认的上下文中去，一旦这样做，很难切回最初捕获的上下文。 123456789private async void Button1_Click(object sender, EventArgs e) &#123; await GetTaskAsync().ConfigureAwait(continueOnCapturedContext:false); await GetTaskAsync(); await GetTaskAsync(); string aa = \"\"; //在默认的上下文中执行，回不到第一个await之前捕获的上下文了。 &#125; 但是可以通过调整代码结构，把与上下文无关的代码移到新的方法。 123456789101112131415161718192021222324252627282930private async void OnCommand(object sender,RoutedEventArgs e)&#123; var viewModel = DataContext as SampleViewModel; try&#123; Config config = await ReadConfigAsync(viewModel); await viewModel.Update(config); //更新UI控件，需要在特定的上下文里 &#125; catch(Exception ex)when(logMessage(viewModel,ex))&#123; &#125; &#125;//不需要在特定的上下文中执行private async Task&lt;Config&gt; ReadConfigAsync(SampleViewModel viewModel)&#123; var userInput = viewModel.webSite; var result = await DownloadAsync(userInput).ConfigureAwait(false); var items = XELement.Parse(result); var userConfig = from node in items.Descendants() where node.Name == \"Config\" select node.Value; var configUrl = userConfig.SingleOrDefault(); if(configUrl != null)&#123; result = await DownloadAsync(configUrl).ConfigureAwait(false); //虽然前面有了ConfigureAwait(false),但依然要写上 config = await ParseConfig(result) .ConfigureAwait(false); &#125; else&#123; config = new Config(); &#125; return config;&#125; 如果编写的是应用程序级代码，不要使用ConfigureAwait(false)，避免程序崩溃。详细阅读ConfigureAwait常见问题解答 Task对象Task对象只是执行异步的一个载体，它有几个重要的方法。Task.WhenAll Task.WhenAny 1234567891011121314151617181920212223242526private async void Button1_Click(object sender, EventArgs e) &#123; var tasks = new List&lt;Task&lt;int&gt;&gt;(); tasks.Add(GetTask()); tasks.Add(GetTask()); tasks.Add(GetTask()); tasks.Add(GetTask()); tasks.Add(GetTask()); //WhenAll 会根据现有的一批任务创建一个新任务 var results = await Task.WhenAll(tasks); //Task.whenAny返回的是最先执行完毕的那项任务 var result = await (await Task.WhenAny(tasks)); &#125; private async Task&lt;int&gt; GetTask() &#123; var task = new Task&lt;int&gt;(() =&gt; &#123; return 5; &#125;); task.Start(); return await task; &#125; 如果有多项任务，而且要求必须对已经执行的每项任务的结果做一些处理，这些任务不会互相依赖。在考虑性能的情况下，当然想哪些先完成，哪些结果就先拿来处理，首先想到是用WhenAny方法，但是每一次WhenAny就创建一项新任务，效率不太好。这时可以考虑使用TaskCompletionSource,这是一个可以容纳异步任务执行结果的地方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static Task&lt;T&gt;[] OrderByCompletion&lt;T&gt;(this IEnumerable&lt;Task&lt;T&gt;&gt; tasks) &#123; var sourceTasks = tasks.ToList(); var completionSources = new TaskCompletionSource&lt;T&gt;[sourceTasks.Count]; var outputTasks = new Task&lt;T&gt;[completionSources.Length]; for(int i = 0; i &lt; completionSources.Length; i++) &#123; completionSources[i] = new TaskCompletionSource&lt;T&gt;(); outputTasks[i] = completionSources[i].Task; &#125; int nextTaskIndex = -1; //每项任务执行完后，然后执行的方法。 Action&lt;Task&lt;T&gt;&gt; continuation = completed =&gt; &#123; //Interlocked.Increment确保线程安全 var bucket = completionSources[Interlocked.Increment(ref nextTaskIndex)]; bucket.TrySetResult(completed.Result); &#125;; foreach(var inputTask in sourceTasks) &#123; //借用了委托，当任务完成后，在委托方法里处理任务结果 inputTask.ContinueWith(continuation, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default); &#125; return outputTasks; &#125; // 摘要: // 创建根据 continuationOptions 中指定的条件加以执行的延续任务。 // // 参数: // continuationAction: // 根据在 continuationOptions 中指定的条件运行的操作。 在运行时，委托将作为一个自变量传递给完成的任务。 // continuationOptions: // 用于设置计划延续任务的时间以及延续任务的工作方式的选项。 public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler); [Flags] public enum TaskContinuationOptions &#123; ...... ...... // // 摘要: // 指定应同步执行延续任务。 指定此选项后，延续任务在导致前面的任务转换为其最终状态的相同线程上运行。 如果在创建延续任务时已经完成前面的任务，则延续任务将在创建此延续任务的线程上运行。 // 如果前面任务的 System.Threading.CancellationTokenSource 已在一个 finally（在 Visual Basic // 中为 Finally）块中释放，则使用此选项的延续任务将在该 finally 块中运行。 只应同步执行运行时间非常短的延续任务。 由于任务以同步方式执行，因此无需调用诸如 // System.Threading.Tasks.Task.Wait 的方法来确保调用线程等待任务完成。 ExecuteSynchronously = 524288 &#125; 考虑任务支持取消功能可以通过CancellationToke这个struct类型实现任务的取消功能，如果调用者请求取消，则ThrowIfCancellationRequested()方法会抛出System.OperationCanceledException异常。 1234567891011121314151617181920212223242526272829303132public Task RunPayroll() =&gt; RunPayroll(new CancellationToken(), null);public Task RunPayroll(CancellationToken cancellationToken) =&gt; RunPayroll(cancellationToken, null);public Task RunPayroll(IProgress&lt;int, string&gt; progress) =&gt; RunPayroll(new CancellationToken(), null); public async Task RunPayroll(CancellationToken cancellationToken,IProgress&lt;int,string&gt; progress) &#123; progress?.Report(0, \"第一步\"); var result0 = await RunTask0(); cancellationToken.ThrowIfCancellationRequested(); progress?.Report(1, \"第二步\"); var result1 = await RunTask1(); cancellationToken.ThrowIfCancellationRequested(); progress?.Report(1, \"第三步\"); var result2 = await RunTask2(); cancellationToken.ThrowIfCancellationRequested(); progress?.Report(1, \"第四步\"); var result3 = await RunTask3(); cancellationToken.ThrowIfCancellationRequested(); &#125;/// &lt;summary&gt; /// 监控进度 /// &lt;/summary&gt; /// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt; /// &lt;typeparam name=\"T1\"&gt;&lt;/typeparam&gt; public interface IProgress&lt;T, T1&gt; &#123; void Report(T t, T1 t1); &#125; 调用方可以通过CancellationTokenSource对象请求取消 123456789101112131415private async void Button1_Click(object sender, EventArgs e)&#123; var cts = new CancellationTokenSource(); try &#123; var task = RunPayroll(cts.Token); cts.Cancel(); //取消 await task; &#125; catch(OperationCanceledException ex) &#123; &#125; &#125; 如果异步任务方法的返回值是void，调用方无法遵循正常途径处理异常，只能通过专门的处理程序处理异常。因此，建议返回值为void的异步方法不支持取消功能。 缓存异步方法的返回值如果程序因为频繁分配Task对象而使得效率低下，可以考虑使用ValueTask优化。ValueTask提供了一个接受Task参数的构造函数，ValueTask是Struct类型。 12345678910111213141516public ValueTask&lt;IEnumerable&lt;int&gt;&gt; GetData(int a,int b)&#123; if (a &lt; b) &#123; return new ValueTask&lt;IEnumerable&lt;int&gt;&gt;(cacheData); //从缓存中取 &#125; else &#123; async Task&lt;IEnumerable&lt; int &gt;&gt; load() //内嵌异步方法 &#123; var result = await RunTask(); return result; &#125; return new ValueTask&lt;IEnumerable&lt;int&gt;&gt;(load()); //接受Task参数的构造函数 &#125;&#125; 千万确认性能瓶颈是因为内存分配的开销导致，再考虑把Task换成ValueTask，如果需要实时获取数据就没必要使用ValueTask。 参考书籍：《Effective C#》进阶篇，针对C# 7.0更新","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huangbaishi.github.io/categories/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://huangbaishi.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Task","slug":"Task","permalink":"http://huangbaishi.github.io/tags/Task/"}]}]}