<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>基于任务的异步编程 | 人生在勤，不索何获。 | 学海无涯~ 学海无涯~</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="异步,Task">
    <meta name="description" content="记录《Effective C#》学习过程。 任务运行的几种方法123456789101112131415161718&#x2F;&#x2F;1.new方式实例化一个Task，需要通过Start方法启动         Task task &#x3D; new Task(() &#x3D;&gt;         &amp;#123;                            Console.WriteLine($&quot;task1的线程I">
<meta property="og:type" content="article">
<meta property="og:title" content="基于任务的异步编程">
<meta property="og:url" content="http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/index.html">
<meta property="og:site_name" content="人生在勤，不索何获。">
<meta property="og:description" content="记录《Effective C#》学习过程。 任务运行的几种方法123456789101112131415161718&#x2F;&#x2F;1.new方式实例化一个Task，需要通过Start方法启动         Task task &#x3D; new Task(() &#x3D;&gt;         &amp;#123;                            Console.WriteLine($&quot;task1的线程I">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-18T19:52:40.000Z">
<meta property="article:modified_time" content="2020-02-14T17:03:38.028Z">
<meta property="article:author" content="舒碧">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="Task">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="人生在勤，不索何获。" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/panda1.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">舒碧</h5>
          <a href="mailto:1732565636@qq.com" title="1732565636@qq.com" class="mail">1732565636@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives" target="_blank" >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/huangshubi" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">基于任务的异步编程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">基于任务的异步编程</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-01-18T19:52:40.000Z" itemprop="datePublished" class="page-time">
  2020-01-18
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/">代码优化</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#任务运行的几种方法"><span class="post-toc-number">1.</span> <span class="post-toc-text">任务运行的几种方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#使用异步方法执行异步工作"><span class="post-toc-number">2.</span> <span class="post-toc-text">使用异步方法执行异步工作</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#不要写返回值类型为void的异步方法"><span class="post-toc-number">3.</span> <span class="post-toc-text">不要写返回值类型为void的异步方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#如果要写返回值为void的异步方法，一定要做好异常处理"><span class="post-toc-number">4.</span> <span class="post-toc-text">如果要写返回值为void的异步方法，一定要做好异常处理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#不要同步方法与异步方法组合使用"><span class="post-toc-number">5.</span> <span class="post-toc-text">不要同步方法与异步方法组合使用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#使用异步方法，要考虑线程分配和上下文切换的开销"><span class="post-toc-number">6.</span> <span class="post-toc-text">使用异步方法，要考虑线程分配和上下文切换的开销</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ConfigureAwait-false-方法使用"><span class="post-toc-number">7.</span> <span class="post-toc-text">ConfigureAwait(false)方法使用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Task对象"><span class="post-toc-number">8.</span> <span class="post-toc-text">Task对象</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#考虑任务支持取消功能"><span class="post-toc-number">9.</span> <span class="post-toc-text">考虑任务支持取消功能</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#缓存异步方法的返回值"><span class="post-toc-number">10.</span> <span class="post-toc-text">缓存异步方法的返回值</span></a></li></ol>
        </nav>
    </aside>


<article id="post-使用异步方法执行异步工作"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">基于任务的异步编程</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-01-18 19:52:40" datetime="2020-01-18T19:52:40.000Z"  itemprop="datePublished">2020-01-18</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/">代码优化</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>记录《Effective C#》学习过程。</p>
<h5 id="任务运行的几种方法"><a href="#任务运行的几种方法" class="headerlink" title="任务运行的几种方法"></a><strong>任务运行的几种方法</strong></h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.new方式实例化一个Task，需要通过Start方法启动</span></span><br><span class="line">         Task task = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">         &#123;               </span><br><span class="line">             Console.WriteLine(<span class="string">$"task1的线程ID为<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">         task.Start();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//2.Task.Factory.StartNew(Action action)创建和启动一个Task</span></span><br><span class="line">         Task task2 = Task.Factory.StartNew(() =&gt;</span><br><span class="line">           &#123;        </span><br><span class="line">               Console.WriteLine(<span class="string">$"task2的线程ID为<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//3.Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task</span></span><br><span class="line">         Task task3 = Task.Run(() =&gt;</span><br><span class="line">           &#123;                  </span><br><span class="line">               Console.WriteLine(<span class="string">$"task3的线程ID为<span class="subst">&#123; Thread.CurrentThread.ManagedThreadId&#125;</span>"</span>);</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用异步方法执行异步工作"><a href="#使用异步方法执行异步工作" class="headerlink" title="使用异步方法执行异步工作"></a><strong>使用异步方法执行异步工作</strong></h5><ul>
<li><p>对于调用异步方法的主调方法来说，只要异步方法已经返回，这里返回的是Task对象，它就可以继续往下执行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MainMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = TaskMethod(); <span class="comment">//调用的开始，异步方法就在跑了</span></span><br><span class="line"></span><br><span class="line">    TaskStatus taskStatus = task.Status; </span><br><span class="line">    <span class="comment">//任务的状态</span></span><br><span class="line">    <span class="comment">//Created = 0,</span></span><br><span class="line">    <span class="comment">//WaitingForActivation = 1,</span></span><br><span class="line">    <span class="comment">//WaitingToRun = 2,</span></span><br><span class="line">    <span class="comment">//Running = 3,</span></span><br><span class="line">    <span class="comment">//WaitingForChildrenToComplete = 4,</span></span><br><span class="line">    <span class="comment">//RanToCompletion = 5,</span></span><br><span class="line">    <span class="comment">//Canceled = 6,</span></span><br><span class="line">    <span class="comment">//Faulted = 7            </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sum = result + <span class="number">2000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">TaskMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = GetTask();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主调用方法执行到await的时候Task如果已经完成，就会返回一个已完成状态的Task对象，并且继续执行await的下一条语句，就像同步一样。</p>
</li>
<li><p>主调用方法执行到await的时候Task如果已经还未完成，底层的机制就是编译器把await后面的语句生成delegate，写入相应的状态信息。直到任务完成，会有一个SynchronizationContext类恢复delegate运行的情境到await之前的样子（控制台是没有SynchronizationContext的）。</p>
</li>
<li><p>一定要等候任务的执行结果，否则有异常也不会抛出来。</p>
</li>
<li><p>await后面的语句，可能是当前线程来做，也可能是另一条线程。</p>
</li>
<li><p>Task.Wait()、Task.Result可以做到等候Task执行完毕，才往下跑，但是会让当前线程阻塞。</p>
</li>
</ul>
<h5 id="不要写返回值类型为void的异步方法"><a href="#不要写返回值类型为void的异步方法" class="headerlink" title="不要写返回值类型为void的异步方法"></a><strong>不要写返回值类型为void的异步方法</strong></h5><ol>
<li>主调方法调用返回返回值为void的异步方法，如果异步方法执行报错，主调方法无法catch到它的异常。只能通过App.Domain.UnhandleException事件或其他非常规手段来处理异常。</li>
<li>通过AppDomain.UnhandleExceptioin事件处理异常并不能让程序从异常中恢复。</li>
<li>无法等待返回值为void的异步方法的执行结果，就无法轻易判断它什么时候执行完。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           Test();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//断点进不到catch</span></span><br><span class="line">       &#125;            </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为void的异步方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="keyword">var</span> task = GetTask();</span><br><span class="line">       <span class="keyword">var</span> result = <span class="keyword">await</span> task;            </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 应用程序的主入口点。</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   [<span class="meta">STAThread</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       Application.EnableVisualStyles();</span><br><span class="line">       Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">       AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;</span><br><span class="line"></span><br><span class="line">       Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentDomain_UnhandledException</span>(<span class="params"><span class="keyword">object</span> sender, UnhandledExceptionEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="comment">//断点可以进来</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="如果要写返回值为void的异步方法，一定要做好异常处理"><a href="#如果要写返回值为void的异步方法，一定要做好异常处理" class="headerlink" title="如果要写返回值为void的异步方法，一定要做好异常处理"></a><strong>如果要写返回值为void的异步方法，一定要做好异常处理</strong></h5><ol>
<li><p>第一种：简单的记录异常，不会妨碍程序继续往下执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = GetTask();</span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Log(ex.ToString()); <span class="comment">//伪代码            </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种：借助异常过滤器      </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;                        </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = GetTask();</span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)<span class="keyword">when</span>(LogMessage(ex)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1：如果LogMessage返回true，可以catch到异常,程序还能往下执行。</span></span><br><span class="line">        <span class="comment">//如果catch里面又抛出异常，另说。</span></span><br><span class="line">        <span class="comment">//2：第二如果LogMessage返回false，catch不到异常，会把异常重新抛出，</span></span><br><span class="line">        <span class="comment">//能在AppDomain.CurrentDomain.UnhandledException捕捉，整个程序会				 //停掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">LogMessage</span>(<span class="params">Exception ex</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log(ex.ToString()); <span class="comment">//伪代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种：把所执行的异步工作视为Task，处理异常的逻辑分别表示通用的<code>Action&lt;Exception&gt;</code>、<code>Func&lt;Exception,bool&gt;</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"><span class="keyword">this</span> Task task,Action&lt;Exception&gt; onErrors</span>)</span></span><br><span class="line"><span class="function"></span>&#123;                        </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        onErrors(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"><span class="keyword">this</span> Task task, Func&lt;Exception,<span class="keyword">bool</span>&gt; onErrors</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)<span class="keyword">when</span>(onErrors(ex))</span><br><span class="line">    &#123;</span><br><span class="line">        onErrors(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>假如希望有些异常能从中恢复</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> Test2&lt;TException&gt;(<span class="keyword">this</span> Task task, Action&lt;TException&gt; recovery,Func&lt;Exception,<span class="keyword">bool</span>&gt; onError) </span><br><span class="line">            <span class="keyword">where</span> TException : Exception</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> task;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)<span class="keyword">when</span>(onError(ex))  </span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(TException ex2) <span class="comment">//如果onError返回false，就有可能catch到TException,并从中恢复</span></span><br><span class="line">            &#123;</span><br><span class="line">                recovery(ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="不要同步方法与异步方法组合使用"><a href="#不要同步方法与异步方法组合使用" class="headerlink" title="不要同步方法与异步方法组合使用"></a><strong>不要同步方法与异步方法组合使用</strong></h5><p>第一种情况：同步方法里调用异步方法</p>
<ul>
<li>原因一：捕获异常麻烦，通过<code>Task.Wait()</code>或者<code>Task.Result</code>来等待Task执行完毕，系统所抛出的异常是非具体的，而是<code>AggregateException</code>类型异常。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task1 = GetTask1();</span><br><span class="line">        <span class="keyword">var</span> task2 = GetTask2();</span><br><span class="line">        <span class="keyword">var</span> result1 = task1.Result;</span><br><span class="line">        <span class="keyword">var</span> result2 = task2.Result;</span><br><span class="line">        <span class="keyword">return</span> result1 + result2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(AggregateException e)<span class="keyword">when</span>(e.InnerExceptions.FirstOrDefault().GetType()==<span class="keyword">typeof</span>(KeyNotFoundException))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因二：代码如下，可能发生死锁，GUI及Asp.Net情境下的SynchronizationContext只包含一条线程。<code>Task.Wait()</code>会让这条线程阻塞，而await下面的语句又需要这条线程才能跑。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = Test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> a = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> b = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> c = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> d = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    _ = task.Result;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span> +</span><br><span class="line">                      <span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span> +</span><br><span class="line">                      <span class="string">"aaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">string</span> a = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> b = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> c = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">string</span> d = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Thread.Sleep相比，Task.Delay是一种异步的延时机制，允许线程去做其他事。</p>
<p>第二种情况：异步里启动另一个异步任务，并在另一个异步任务里执行计算量较大的同步操作。</p>
<p>原因一：本来就有线程执行这项异步操作，没必要需要开辟更多的线程执行。</p>
<p>原因二：异步方法开辟新的线程执行计算量较大的同步操作，误导开发调用者。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line">    <span class="comment">//调试得到 当前线程ID：1</span></span><br><span class="line">        <span class="keyword">await</span> GetTaskAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">ComputeValue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line">        <span class="comment">//调试得到 当前线程ID：4</span></span><br><span class="line">        <span class="keyword">double</span> finalAnswer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            finalAnswer += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalAnswer;</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">double</span>&gt; <span class="title">GetTaskAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="keyword">double</span>&gt;(()=&gt; &#123;                				MessageBox.Show(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line"><span class="comment">//调试得到 当前线程ID：3</span></span><br><span class="line">            Task.Run(() =&gt; ComputeValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        task.Start();</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> task;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>异步任务嵌套异步任务是可以的，只是应该是将自己无法完成或者不便完成的任务交给另外的异步去做，而不是随意开辟新的线程，把本来就可以自己执行的工作转交出去。</p>
<h5 id="使用异步方法，要考虑线程分配和上下文切换的开销"><a href="#使用异步方法，要考虑线程分配和上下文切换的开销" class="headerlink" title="使用异步方法，要考虑线程分配和上下文切换的开销"></a><strong>使用异步方法，要考虑线程分配和上下文切换的开销</strong></h5><p>可以异步，但不要随便用。</p>
<p>原因一：线程成本，当前线程就能做好的工作转交给另一个线程做、前面线程的确减轻负担，但后面线程也增加负担了。所以在当前线程是稀缺且重要的资源，例如GUI应用程序的UI线程，才应该把计算量较大的工作转交给其他异步去做。</p>
<p>原因二：上下文切换成本，await任务之后，可以正常往下执行，是因为<code>SynchronizationContext</code>记住了await之前的所有状态。等任务执行完后，切换到原来的<code>SynchronizationContext</code>。</p>
<p>有些异步没有必要开辟新线程，例如<a href="https://docs.microsoft.com/en-us/dotnet/standard/io/asynchronous-file-i-o" target="_blank" rel="noopener">文件异步I/O</a>、<a href="https://docs.microsoft.com/en-us/dotnet/framework/network-programming/making-asynchronous-requests" target="_blank" rel="noopener">Web请求</a>，文件异步可以通过端口实现，Web请求可以通过网络中断实现。</p>
<h5 id="ConfigureAwait-false-方法使用"><a href="#ConfigureAwait-false-方法使用" class="headerlink" title="ConfigureAwait(false)方法使用"></a><strong>ConfigureAwait(false)方法使用</strong></h5><p>如果await语句之后的代码与上下文无关，可以通过调用Task对象的<code>ConfigureAwait(false)</code>告诉系统不必切回到原理捕获的上下文中运行,默认是true。</p>
<p>使用<code>ConfigureAwait(false)</code>好处是提高性能，避免死锁。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;       </span><br><span class="line">          <span class="keyword">await</span> 	GetTaskAsync().ConfigureAwait(continueOnCapturedContext:<span class="literal">false</span>); <span class="comment">//一般不在应用程序级别代码使用false，这里只是举例子。</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//必须在特定的上下文中执行，如果上面设为false</span></span><br><span class="line">          <span class="comment">//抛异常 System.InvalidOperationException:“线程间操作无效:</span></span><br><span class="line">          <span class="comment">//从不是创建控件“button2”的线程访问它。”</span></span><br><span class="line">          <span class="comment">//button2.Text = "dddd"; </span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>如果是在某条await语句处调用ConfigureAwait(false)，而且这里await的任务是异步执行的，系统会把下面的代码安排到默认的上下文中去，一旦这样做，很难切回最初捕获的上下文。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;       </span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync().ConfigureAwait(continueOnCapturedContext:<span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync();</span><br><span class="line">          <span class="keyword">await</span> GetTaskAsync();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">string</span> aa = <span class="string">""</span>; <span class="comment">//在默认的上下文中执行，回不到第一个await之前捕获的上下文了。</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>但是可以通过调整代码结构，把与上下文无关的代码移到新的方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnCommand</span>(<span class="params"><span class="keyword">object</span> sender,RoutedEventArgs e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> viewModel = DataContext <span class="keyword">as</span> SampleViewModel;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Config config = <span class="keyword">await</span> ReadConfigAsync(viewModel); </span><br><span class="line">        <span class="keyword">await</span> viewModel.Update(config); <span class="comment">//更新UI控件，需要在特定的上下文里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)<span class="keyword">when</span>(logMessage(viewModel,ex))&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要在特定的上下文中执行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;Config&gt; <span class="title">ReadConfigAsync</span>(<span class="params">SampleViewModel viewModel</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userInput = viewModel.webSite;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> DownloadAsync(userInput).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">var</span> items = XELement.Parse(result);</span><br><span class="line">    <span class="keyword">var</span> userConfig = <span class="keyword">from</span> node <span class="keyword">in</span> items.Descendants()</span><br><span class="line">        <span class="keyword">where</span> node.Name == <span class="string">"Config"</span></span><br><span class="line">        <span class="keyword">select</span> node.Value;</span><br><span class="line">    <span class="keyword">var</span> configUrl = userConfig.SingleOrDefault();</span><br><span class="line">    <span class="keyword">if</span>(configUrl != <span class="literal">null</span>)&#123;</span><br><span class="line">        result = <span class="keyword">await</span> DownloadAsync(configUrl).ConfigureAwait(<span class="literal">false</span>); <span class="comment">//虽然前面有了ConfigureAwait(false),但依然要写上</span></span><br><span class="line">        config = <span class="keyword">await</span> ParseConfig(result)</span><br><span class="line">            .ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        config = <span class="keyword">new</span> Config();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编写的是应用程序级代码，不要使用<code>ConfigureAwait(false)</code>，避免程序崩溃。详细阅读<a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" target="_blank" rel="noopener">ConfigureAwait常见问题解答</a></p>
<h5 id="Task对象"><a href="#Task对象" class="headerlink" title="Task对象"></a><strong>Task对象</strong></h5><p>Task对象只是执行异步的一个载体，它有几个重要的方法。<code>Task.WhenAll  Task.WhenAny</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> tasks = <span class="keyword">new</span> List&lt;Task&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line">            tasks.Add(GetTask());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//WhenAll 会根据现有的一批任务创建一个新任务</span></span><br><span class="line">            <span class="keyword">var</span> results = <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Task.whenAny返回的是最先执行完毕的那项任务</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> (<span class="keyword">await</span> Task.WhenAny(tasks));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">GetTask</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="keyword">int</span>&gt;(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            task.Start();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果有多项任务，而且要求必须对已经执行的每项任务的结果做一些处理，这些任务不会互相依赖。在考虑性能的情况下，当然想哪些先完成，哪些结果就先拿来处理，首先想到是用WhenAny方法，但是每一次WhenAny就创建一项新任务，效率不太好。这时可以考虑使用TaskCompletionSource,这是一个可以容纳异步任务执行结果的地方。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;T&gt;[] OrderByCompletion&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;Task&lt;T&gt;&gt; tasks)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">var</span> sourceTasks = tasks.ToList();</span><br><span class="line">          <span class="keyword">var</span> completionSources = <span class="keyword">new</span> TaskCompletionSource&lt;T&gt;[sourceTasks.Count];</span><br><span class="line">          <span class="keyword">var</span> outputTasks = <span class="keyword">new</span> Task&lt;T&gt;[completionSources.Length];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; completionSources.Length; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              completionSources[i] = <span class="keyword">new</span> TaskCompletionSource&lt;T&gt;();</span><br><span class="line">              outputTasks[i] = completionSources[i].Task;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> nextTaskIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//每项任务执行完后，然后执行的方法。</span></span><br><span class="line">          Action&lt;Task&lt;T&gt;&gt; continuation = completed =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//Interlocked.Increment确保线程安全</span></span><br><span class="line">              <span class="keyword">var</span> bucket = completionSources[Interlocked.Increment(<span class="keyword">ref</span> nextTaskIndex)];</span><br><span class="line">              bucket.TrySetResult(completed.Result);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">foreach</span>(<span class="keyword">var</span> inputTask <span class="keyword">in</span> sourceTasks)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//借用了委托，当任务完成后，在委托方法里处理任务结果</span></span><br><span class="line">              inputTask.ContinueWith(continuation, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously,</span><br><span class="line">                  TaskScheduler.Default);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> outputTasks;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 摘要:</span></span><br><span class="line">      <span class="comment">//     创建根据 continuationOptions 中指定的条件加以执行的延续任务。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 参数:</span></span><br><span class="line">      <span class="comment">//   continuationAction:</span></span><br><span class="line">      <span class="comment">//     根据在 continuationOptions 中指定的条件运行的操作。 在运行时，委托将作为一个自变量传递给完成的任务。       </span></span><br><span class="line">      <span class="comment">//   continuationOptions:</span></span><br><span class="line">      <span class="comment">//     用于设置计划延续任务的时间以及延续任务的工作方式的选项。       </span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Task <span class="title">ContinueWith</span>(<span class="params">Action&lt;Task&lt;TResult&gt;&gt; continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler</span>)</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Flags</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> TaskContinuationOptions</span><br><span class="line">  &#123;</span><br><span class="line">     ......</span><br><span class="line">     ......</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 摘要:</span></span><br><span class="line">      <span class="comment">//     指定应同步执行延续任务。 指定此选项后，延续任务在导致前面的任务转换为其最终状态的相同线程上运行。 如果在创建延续任务时已经完成前面的任务，则延续任务将在创建此延续任务的线程上运行。</span></span><br><span class="line">      <span class="comment">//     如果前面任务的 System.Threading.CancellationTokenSource 已在一个 finally（在 Visual Basic</span></span><br><span class="line">      <span class="comment">//     中为 Finally）块中释放，则使用此选项的延续任务将在该 finally 块中运行。 只应同步执行运行时间非常短的延续任务。 由于任务以同步方式执行，因此无需调用诸如</span></span><br><span class="line">      <span class="comment">//     System.Threading.Tasks.Task.Wait 的方法来确保调用线程等待任务完成。</span></span><br><span class="line">      ExecuteSynchronously = <span class="number">524288</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="考虑任务支持取消功能"><a href="#考虑任务支持取消功能" class="headerlink" title="考虑任务支持取消功能"></a><strong>考虑任务支持取消功能</strong></h5><p>可以通过CancellationToke这个struct类型实现任务的取消功能，如果调用者请求取消，则ThrowIfCancellationRequested()方法会抛出System.OperationCanceledException异常。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">RunPayroll</span>(<span class="params"></span>)</span> =&gt; RunPayroll(<span class="keyword">new</span> CancellationToken(), <span class="literal">null</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">RunPayroll</span>(<span class="params">CancellationToken cancellationToken</span>)</span> =&gt; RunPayroll(cancellationToken, <span class="literal">null</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">RunPayroll</span>(<span class="params">IProgress&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; progress</span>)</span> =&gt; RunPayroll(<span class="keyword">new</span> CancellationToken(), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">RunPayroll</span>(<span class="params">CancellationToken cancellationToken,IProgress&lt;<span class="keyword">int</span>,<span class="keyword">string</span>&gt; progress</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          progress?.Report(<span class="number">0</span>, <span class="string">"第一步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result0 = <span class="keyword">await</span> RunTask0();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">          progress?.Report(<span class="number">1</span>, <span class="string">"第二步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result1 = <span class="keyword">await</span> RunTask1();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">          progress?.Report(<span class="number">1</span>, <span class="string">"第三步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result2 = <span class="keyword">await</span> RunTask2();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">          progress?.Report(<span class="number">1</span>, <span class="string">"第四步"</span>);</span><br><span class="line">          <span class="keyword">var</span> result3 = <span class="keyword">await</span> RunTask3();</span><br><span class="line">          cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 监控进度</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name="T"&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name="T1"&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">      public interface IProgress&lt;T, T1&gt;</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="function"><span class="keyword">void</span> <span class="title">Report</span>(<span class="params">T t, T1 t1</span>)</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>调用方可以通过CancellationTokenSource对象请求取消</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = RunPayroll(cts.Token);</span><br><span class="line">        cts.Cancel(); <span class="comment">//取消</span></span><br><span class="line">        <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(OperationCanceledException ex)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果异步任务方法的返回值是void，调用方无法遵循正常途径处理异常，只能通过专门的处理程序处理异常。因此，建议返回值为void的异步方法不支持取消功能。</p>
<h5 id="缓存异步方法的返回值"><a href="#缓存异步方法的返回值" class="headerlink" title="缓存异步方法的返回值"></a><strong>缓存异步方法的返回值</strong></h5><p>如果程序因为频繁分配Task对象而使得效率低下，可以考虑使用ValueTask优化。ValueTask提供了一个接受Task参数的构造函数，ValueTask是Struct类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ValueTask&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt; GetData(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt;(cacheData); <span class="comment">//从缓存中取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">async</span> Task&lt;IEnumerable&lt; <span class="keyword">int</span> &gt;&gt; load() <span class="comment">//内嵌异步方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> RunTask();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;IEnumerable&lt;<span class="keyword">int</span>&gt;&gt;(load()); <span class="comment">//接受Task参数的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>千万确认性能瓶颈是因为内存分配的开销导致，再考虑把Task换成ValueTask，如果需要实时获取数据就没必要使用ValueTask。</p>
<p>参考书籍：《Effective C#》进阶篇，针对C# 7.0更新</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-02-14T17:03:38.028Z" itemprop="dateUpdated">2020-02-14 17:03:38</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="http://huangbaishi.github.io">
            <img src="/img/panda1.jpg" alt="舒碧">
            舒碧
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Task/" rel="tag">Task</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/&title=《基于任务的异步编程》 — 人生在勤，不索何获。&pic=http://huangbaishi.github.io/img/panda1.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/&title=《基于任务的异步编程》 — 人生在勤，不索何获。&source=c#、dotnet等学习总结" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《基于任务的异步编程》 — 人生在勤，不索何获。&url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/&via=http://huangbaishi.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/01/21/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%E8%AE%B0%E5%BD%95/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">学习链接记录</h4>
      </a>
    </div>
  

  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>舒碧 &copy; 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/&title=《基于任务的异步编程》 — 人生在勤，不索何获。&pic=http://huangbaishi.github.io/img/panda1.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/&title=《基于任务的异步编程》 — 人生在勤，不索何获。&source=c#、dotnet等学习总结" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《基于任务的异步编程》 — 人生在勤，不索何获。&url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/&via=http://huangbaishi.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://huangbaishi.github.io/2020/01/18/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%B7%A5%E4%BD%9C/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEdklEQVR42u3aSW7jQBAEQP//05rzAEM5s4oesOXgydBCdQcN1NZfX/H1entdffL93fI7t/e8uvPVJ2+7MGHChAnTI5lmC83hcqwccbPh4S4wYcKECdPhTPk28kX83LaT8P8+Zcn3jgkTJkyYfhtT8ncClKwhT0faNWDChAkTJkzD28XvzgJ/u/lZCoIJEyZMmD6Pqb3drPh8v6y8lZyH/9n9MWHChAnTJzHdO3o86++bL0yYMGHC9DCmV3m1392MOfMEYp9efLMLTJgwYcJ0LFMeIDel6b6wzDn2jenLx4AJEyZMmA5kmgX7PCS3hXSL26LMUgRMmDBhwnQu0yxwzsrjJL3YHMrZlMfJqjBhwoQJ04lMm+M47fgz3+qsMJ4d2YkeHiZMmDBhOpxpM1bMgWaBfDa2nKU1l69jwoQJE6bDmfLjNXnpmL+yL603Td7onwMTJkyYMB3OlDRnX+W16jrfWujmq/2mC44JEyZMmI5lmpWvm2ZuUmC3DeX399kU6pgwYcKE6VymJOrNjsvkx2hmZe1d5XGdrGDChAkTpqOY2oKwfbdopJajys1wNOfGhAkTJkyfwbQP6nkhnbw7a8i2jekCHRMmTJgwHcuUN0/3i8gbu5tDP3mJewMQJkyYMGE6lqkN/LOGbHvP2Sv541/9H2HChAkTpkcyzcJ8MiPNt52nEbMN35COYMKECROmY5k2V/7zSdKQl7KzX2kL5huAMGHChAnTY5juDfazlmtbqc9CfnskCBMmTJgwnc60CeGzcWPSOM5bwHmTd5MoYMKECROm05naNmsCkV/5b7Uos339456YMGHChOlYpn3fdxZoZ03efXm8ifuYMGHChOlcprZQTEJsG3Rnv/J+q+3aIlBMmDBhwnQUUx5i2zFhssRNmdrCrRrNmDBhwoTpI5hmiUIeXPfF8P54UH7Q56/XMWHChAnTsUz3/kC7mU2KkKcpmxThR54DJkyYMGF6DNM+rLYD0bbwbkP77MFgwoQJE6ZzmYauZZM3X3Q+dJw1eZMHiQkTJkyYPo8pL1A3bdlkFJqXx+22NykFJkyYMGE6l2kfXP/PUZ4EcXbYqL0nJkyYMGE6i+knttGyzkaks0/+YJMXEyZMmDA9kqk+vDJa+qYY3jd58xVGApgwYcKE6SimttG5P5oz21I7qtykCJe9cEyYMGHCdCzTLADPhp15oTscN45SnG9WhQkTJkyYPoIp/9rsiMy9ZXY+tmzHrpe9cEyYMGHCdCDTbKtto/Zrcc2Shv0jiYaamDBhwoTp8Uyv8mpZ21K5CMmjRnC7tqgXjgkTJkyYHsw0C5PJVmdLTL41+639EBQTJkyYMJ3LNDu+s+GYJQR58rFp6V5+FxMmTJgwHc70PijOgnSbUrTjzOGGZ2NUTJgwYcL0K5na7eWpRrvtNq1pHwkmTJgwYfo9TO0mZ6XsbNiZl+t1iY4JEyZMmA5nSkLp7JjLrBhuOdojRHUBjwkTJkyYjmVq2505Vjuk3IxL8zHnbSiYMGHChOnpTH8AAS6WhwHYLPcAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '舒碧博客';
            clearTimeout(titleTime);
        } else {
            document.title = '舒碧博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
