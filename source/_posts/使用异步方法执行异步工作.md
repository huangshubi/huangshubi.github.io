---
title: 基于任务的异步编程
date: 2020-01-18 19:52:40
categories:
- 代码优化
tags:
- 异步
- Task
---

###### **使用异步方法执行异步工作**

- 对于调用异步方法的主调方法来说，只要异步方法已经返回，这里返回的是Task对象，它就可以继续往下执行。

  ```c#
  		public static async void MainMethod()
          {
              var task = TaskMethod(); //调用的开始，异步方法就在跑了
  
              TaskStatus taskStatus = task.Status; 
              //任务的状态
              //Created = 0,
              //WaitingForActivation = 1,
              //WaitingToRun = 2,
              //Running = 3,
              //WaitingForChildrenToComplete = 4,
              //RanToCompletion = 5,
              //Canceled = 6,
              //Faulted = 7            
  
              var a = "";
              var b = "";
              var c = "";
              var d = "";
  
              var result = await task;
  
              var sum = result + 2000;
          }
  
          public static async Task<int> TaskMethod()
          {
              var task = new Task<int>(() =>
              {
                  int sum = 0;
                  for (int i = 0; i < 200000000; i++)
                  {                    
                      sum = sum + i * 2;
                  }
                  return sum;
              });
              return await task;
          }
  ```

- 主调用方法执行到await的时候Task如果已经完成，就会返回一个已完成状态的Task对象，并且继续执行await的下一条语句，就像同步一样。

- 主调用方法执行到await的时候Task如果已经还未完成，底层的机制就是编译器把await后面的语句生成delegate，写入相应的状态信息。直到任务完成，会有一个SynchronizationContext类恢复delegate运行的情境到await之前的样子（控制台是没有SynchronizationContext的）。

- 一定要等候任务的执行结果，否则有异常也不会抛出来。

- await后面的语句，可能是当前线程来做，也可能是另一条线程。

- Task.Wait()、Task.Result可以做到等候Task执行完毕，才往下跑，但是会让当前线程阻塞。

###### **不要写返回值类型为void的异步方法**

1. 主调方法调用返回返回值为void的异步方法，如果异步方法执行报错，主调方法无法catch到它的异常。只能通过App.Domain.UnhandleException事件或其他非常规手段来处理异常。
2. 通过AppDomain.UnhandleExceptioin事件处理异常并不能让程序从异常中恢复。
3. 无法等待返回值为void的异步方法的执行结果，就无法轻易判断它什么时候执行完。

```c#
    private async void Button1_Click(object sender, EventArgs e)
    {
        try
        {
            Test();
        }
        catch(Exception ex)
        {
            //断点进不到catch
        }            
    }  

	//返回值为void的异步方法
    static async void Test()
    {
        throw new Exception();
        var task = new Task<bool>(() => {
            return true;
        });
        var result = await task;            
    }

    /// <summary>
    /// 应用程序的主入口点。
    /// </summary>
    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);

        AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;

        Application.Run(new Form1());

    }
    private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
    {
        //断点可以进来
        throw new NotImplementedException();
    }
```
###### **如果要写返回值为void的异步方法，一定要做好异常处理**

1. 第一种：简单的记录异常，不会妨碍程序继续往下执行

   ```c#
   static async void Test1()
   {
       var task = new Task(() => {
           throw new Exception();
           return;
       });
       try
       {
           await task;
       }
       catch (Exception ex)
       {
           Log(ex.ToString()); /
               /伪代码
       }
   }
   ```

2. 第二种：借助异常过滤器      

   ```C#
   static async void Test1()
   {                        
       try
       {
           throw new Exception();
           var task = new Task(() => {
               throw new Exception();
               return;
           });
           await task;
       }
       catch(Exception ex)when(LogMessage(ex)) 
       {
           //1：如果LogMessage返回true，可以catch到异常,程序还能往下执行。
           //如果catch里面又抛出异常，另说。
           //2：第二如果LogMessage返回false，catch不到异常，会把异常重新抛出，
           //能在AppDomain.CurrentDomain.UnhandledException捕捉，整个程序会				 //停掉
       }
   }
   
   static bool LogMessage(Exception ex)
   {
       Log(ex.ToString()); //伪代码
       return false;
   }
   ```

3. 第三种：把所执行的异步工作视为Task，处理异常的逻辑分别表示通用的`Action<Exception>`、`Func<Exception,bool>`

   ```c#
       static async void Test1(this Task task,Action<Exception> onErrors)
       {                        
           try
           {                             
               await task;
           }
           catch(Exception ex)
           {
               onErrors(ex);
           }
       }
       static async void Test2(this Task task, Func<Exception,bool> onErrors)
       {
           try
           {
               await task;
           }
           catch (Exception ex)when(onErrors(ex))
           {
               onErrors(ex);
           }
       }
   ```

4. 假如希望有些异常能从中恢复

   ```C#
   static async void Test2<TException>(this Task task, Action<TException> recovery,Func<Exception,bool> onError) 
               where TException : Exception
           {
               try
               {
                   await task;
               }
               catch (Exception ex)when(onError(ex))  
               {
                   
               }
               catch(TException ex2) //如果onError返回false，就有可能catch到TException,并从中恢复
               {
                   recovery(ex2);
               }
           }
   ```

   

5. 

6. 

7. 

    

