---
title: 基于任务的异步编程
date: 2020-01-18 19:52:40
categories:
- 代码优化
tags:
- 异步
- Task
---

###### 	**使用异步方法执行异步工作**

- 对于调用异步方法的主调方法来说，只要异步方法已经返回，这里返回的是Task对象，它就可以继续往下执行。

  ```c#
  		public static async void MainMethod()
          {
              var task = TaskMethod(); //调用的开始，异步方法就在跑了
  
              TaskStatus taskStatus = task.Status; 
              //任务的状态
              //Created = 0,
              //WaitingForActivation = 1,
              //WaitingToRun = 2,
              //Running = 3,
              //WaitingForChildrenToComplete = 4,
              //RanToCompletion = 5,
              //Canceled = 6,
              //Faulted = 7            
  
              var a = "";
              var b = "";
              var c = "";
              var d = "";
  
              var result = await task;
  
              var sum = result + 2000;
          }
  
          public static async Task<int> TaskMethod()
          {
              var task = new Task<int>(() =>
              {
                  int sum = 0;
                  for (int i = 0; i < 200000000; i++)
                  {                    
                      sum = sum + i * 2;
                  }
                  return sum;
              });
              return await task;
          }
  ```

- 主调用方法执行到await的时候Task如果已经完成，就会返回一个已完成状态的Task对象，并且继续执行await的下一条语句，就像同步一样。

- 主调用方法执行到await的时候Task如果已经还未完成，底层的机制就是编译器把await后面的语句生成delegate，写入相应的状态信息。直到任务完成，会有一个SynchronizationContext类恢复delegate运行的情境到await之前的样子（控制台是没有SynchronizationContext的）。

- 一定要等候任务的执行结果，否则有异常也不会抛出来。

- await后面的语句，可能是当前线程来做，也可能是另一条线程。

- Task.Wait()、Task.Result可以做到等候Task执行完毕，才往下跑。但是会让当前线程阻塞。

**不要写返回值类型为void的异步方法**

1. 主调方法调用返回返回值为void的异步方法，如果异步方法执行报错，主调方法无法catch到它的异常。只能通过App.Domain.UnhandleException事件或其他非常规手段来处理异常。
2. 通过AppDomain.UnhandleExceptioin事件处理异常并不能让程序从异常中恢复。
3. 无法等待返回值为void的异步方法的执行结果，就无法轻易判断它什么时候执行完。

```c#
    private async void Button1_Click(object sender, EventArgs e)
    {
        try
        {
            Test();
        }
        catch(Exception ex)
        {
            //断点进不到catch
        }            
    }  

	//返回值为void的异步方法
    static async void Test()
    {
        throw new Exception();
        var task = new Task<bool>(() => {
            return true;
        });
        var result = await task;            
    }

    /// <summary>
    /// 应用程序的主入口点。
    /// </summary>
    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);

        AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;

        Application.Run(new Form1());

    }
    private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
    {
        //断点可以进来
        throw new NotImplementedException();
    }
```
###### 返回值为void的异步方法，做好异常处理