---
title: 并行处理
date: 2020-01-30 13:03:58
tags:
- PLINQ
---

##### 通过Parallel LINQ  (PLINQ) 实现并行算法

通过使用PLINQ提供的方法，可以简单的写出发挥多核CPU优势的代码，也会有线程开销。

对数据源调用AsParallel()方法。

```C#
 public class Test
    {
        public static void MainMethod()
        {
            var students = new List<Student>() {
            new Student(){Age=10 },new Student(){ Age=9},new Student(){ Age=9},new Student(){ Age=9}
            new Student(){ Age=12}};

            //linq to objects
            IEnumerable<Student> filterStudents = students.Where(m => m.Age < 10).
                Select(n => SetStudent(n));

            //对数据源做AsParallel处理 不涉及数据共享，元素顺序没有特定要求。
            //public class ParallelQuery<TSource> : ParallelQuery, IEnumerable<TSource>, IEnumerable
            ParallelQuery<Student> filterStudents1 = students.AsParallel().Where(m => m.Age < 10).
                Select(n => SetStudent(n));

            //linq to sql
            var filterStudents2 = from m in students
                                  where m.Age < 10
                                  select SetStudent(m);

            var filterStudents3 = from m in students.AsParallel()
                                  where m.Age < 10
                                  select SetStudent(m);

        }

        private static Student SetStudent(Student student)
        {
            student.TeacherName = "李楚刀";
            return student;
        }
    }

    internal class Student
    {
        public int Age { get; set; }

        public string TeacherName { get; set; }
    }
```

数据划分，当执行并行查询的时候，第一个步骤是划分数据，划分数据方式包括范围划分、区块划分、带状划分、哈希划分。PLINQ自动的使用适当的算法对数据进行分区，并行并行执行查询的各个部分，然后合并结果。[数据并行模式和PLINQ](https://docs.microsoft.com/en-in/archive/msdn-magazine/2009/december/concurrent-affairs-data-parallel-patterns-and-plinq)。

并行执行任务的算法：pipelining、 stop and go、inverted enumeration

```C#

            //采用 stop & go 算法
          var filterStudents3 = (from m in students.AsParallel()
                                  where m.Age < 10
                                  select SetStudent(m)).ToList();
            //采用 stop & go 算法
            var filterStudents4 = (from m in students.AsParallel()
                                   where m.Age < 10
                                   select SetStudent(m)).ToArray();

            //采用 inverted enumeration 算法 
            var filterStudents5 = from m in students.AsParallel()
                                   where m.Age < 10
                                   select SetStudent(m);
			//一边计算结果 一边对已经计算出来的元素并行地操作
            filterStudents5.ForAll(item => Console.WriteLine(item));
```

LINQ to Objects 是以懒性的方式对查询操作进行求值，只有真正用到查询结果某个值的时候，系统才会去生成。

```C#
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var answer = from n in Enumerable.Range(0, 300)
                         where n.SomeTest()
                         select n.SomeProjection();

            var iter = answer.GetEnumerator();
            Console.WriteLine("start iterating");
            while (iter.MoveNext()) 
            {
                Console.WriteLine("called MoveNext");
                Console.WriteLine(iter.Current);
            }
        }     
    }

    public static class Test
    {
        public static bool SomeTest(this int inputValue)
        {
            Console.WriteLine($"testing element:{inputValue}");
            return inputValue % 10 == 0;
        }

        public static string SomeProjection(this int input)
        {
            Console.WriteLine($"projecting an element:{input}");
            return $"Delivered {input} at {DateTime.Now:T}";
        }
    }
}

截取部分结果说明：
start iterating
testing element:0
projecting an element:0
called MoveNext
Delivered 0 at 15:45:36
testing element:1
testing element:2
testing element:3
testing element:4
testing element:5
testing element:6
testing element:7
testing element:8
testing element:9
testing element:10
projecting an element:10
called MoveNext
Delivered 10 at 15:45:36
testing element:11   又去查询元素
testing element:12
testing element:13
testing element:14
testing element:15
testing element:16
testing element:17
testing element:18
testing element:19
testing element:20
projecting an element:20
called MoveNext
Delivered 20 at 15:45:36
testing element:21
testing element:22
testing element:23
testing element:24
testing element:25
testing element:26
testing element:27
testing element:28
testing element:29
testing element:30
projecting an element:30
called MoveNext
Delivered 30 at 15:45:36
testing element:31
testing element:32
testing element:33
testing element:34
testing element:35
testing element:36
testing element:37
testing element:38
testing element:39
testing element:40
projecting an element:40
called MoveNext
Delivered 40 at 15:45:36
testing element:41
testing element:42
testing element:43
testing element:44
testing element:45
testing element:46
testing element:47
testing element:48
testing element:49
testing element:50
projecting an element:50
called MoveNext
Delivered 50 at 15:45:36
```

当程序下次调用MoveNext()方法时，系统只会执行到能够产生下一项执行结果的地方。

上面的LINQ to Objects 改用为 PLINQ执行

```C#

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var answer = from n in ParallelEnumerable.Range(0, 300)
                         where n.SomeTest()
                         select n.SomeProjection();

            var iter = answer.GetEnumerator();
            Console.WriteLine("start iterating");
            while (iter.MoveNext()) 
            {
                Console.WriteLine("called MoveNext");
                Console.WriteLine(iter.Current);
            }
        }     
    }

    public static class Test
    {
        public static bool SomeTest(this int inputValue)
        {
            Console.WriteLine($"testing element:{inputValue};当前线程：{Thread.CurrentThread.ManagedThreadId}");
            return inputValue % 10 == 0;
        }

        public static string SomeProjection(this int input)
        {
            Console.WriteLine($"projecting an element:{input}");
            return $"Delivered {input} at {DateTime.Now:T}";
        }
    }
}

截取部分结果说明：
start iterating
testing element:0;当前线程：4
testing element:150;当前线程：5
testing element:75;当前线程：3
testing element:225;当前线程：6
testing element:226;当前线程：6
testing element:227;当前线程：6
testing element:228;当前线程：6
testing element:229;当前线程：6
testing element:230;当前线程：6
projecting an element:230
projecting an element:0
projecting an element:150
testing element:76;当前线程：3
testing element:77;当前线程：3
testing element:78;当前线程：3
testing element:79;当前线程：3
testing element:80;当前线程：3
projecting an element:80
testing element:151;当前线程：5
testing element:152;当前线程：5
testing element:153;当前线程：5
testing element:154;当前线程：5
testing element:155;当前线程：5
testing element:156;当前线程：5
testing element:157;当前线程：5
testing element:158;当前线程：5
testing element:159;当前线程：5
testing element:160;当前线程：5
projecting an element:160
testing element:161;当前线程：5
testing element:162;当前线程：5
testing element:231;当前线程：6
testing element:232;当前线程：6
testing element:233;当前线程：6
testing element:234;当前线程：6
testing element:81;当前线程：3
testing element:1;当前线程：4
testing element:163;当前线程：5
testing element:235;当前线程：6
......
called MoveNext
Delivered 230 at 16:05:15
testing element:223;当前线程：5
testing element:131;当前线程：3
testing element:132;当前线程：3
testing element:224;当前线程：5
called MoveNext
Delivered 20 at 16:05:15
testing element:133;当前线程：3
testing element:134;当前线程：3
testing element:135;当前线程：3
testing element:136;当前线程：3
testing element:137;当前线程：3
testing element:138;当前线程：3
testing element:139;当前线程：3
testing element:140;当前线程：3
called MoveNext
projecting an element:140
testing element:141;当前线程：3
testing element:142;当前线程：3
testing element:143;当前线程：3
testing element:144;当前线程：3
testing element:145;当前线程：3
Delivered 150 at 16:05:15
called MoveNext
Delivered 240 at 16:05:15
called MoveNext
Delivered 30 at 16:05:15
called MoveNext
Delivered 160 at 16:05:15
called MoveNext                   出现了交叉情况
testing element:146;当前线程：3
testing element:147;当前线程：3
testing element:148;当前线程：3
testing element:149;当前线程：3
Delivered 250 at 16:05:15
called MoveNext
Delivered 40 at 16:05:15
called MoveNext
Delivered 80 at 16:05:15
called MoveNext
Delivered 170 at 16:05:15
called MoveNext
Delivered 260 at 16:05:15
called MoveNext
Delivered 50 at 16:05:15
called MoveNext
Delivered 90 at 16:05:15
called MoveNext
Delivered 180 at 16:05:15
called MoveNext
Delivered 270 at 16:05:15
called MoveNext
Delivered 60 at 16:05:15
called MoveNext
Delivered 100 at 16:05:15
called MoveNext
Delivered 190 at 16:05:15
called MoveNext
Delivered 280 at 16:05:15
called MoveNext
Delivered 70 at 16:05:15
called MoveNext
Delivered 110 at 16:05:15
called MoveNext
Delivered 200 at 16:05:15
called MoveNext
Delivered 290 at 16:05:15
called MoveNext
Delivered 120 at 16:05:15
called MoveNext
Delivered 210 at 16:05:15
called MoveNext
Delivered 130 at 16:05:15
called MoveNext
Delivered 220 at 16:05:15
called MoveNext
Delivered 140 at 16:05:15
请按任意键继续. . .

```

程序刚一调用MoveNext()方法，PLINQ马上启动多个线程来计算查询结果。

并行算法的并行程度可能会因为执行的操作受到影响，例如查询里有OrderBy、ThenBy方法，各个任务需要进行协调，还有Skip、SkipWhile、Take、TakeWhile方法也会影响并行程度。

如果想让PLINQ在计算结果时保留源数据的的顺序或者无序，可以通过AsOrdered和AsUnOrdered方法

```C#
var answer = (from n in ParallelEnumerable.Range(0, 300).AsOrdered()
                         where n.SomeTest()
                         select n.SomeProjection()).Skip(10).Take(20);

var answer1 = (from n in ParallelEnumerable.Range(0, 300).AsUnordered()
                          where n.SomeTest()
                          select n.SomeProjection()).Skip(10).Take(20);
```

并行算法里如果有部分逻辑不能以并行方式执行，可以通过AsSequential()方法，将并行序列转换到IEnumerable。

即使使用了PLINQ，它也不一定会并行，只要当它认为会提供效率才会做出并行处理，如果想强制并行处理，可以使用`WithExecutionMode(ParallelExecutionMode.ForceParallelism)`。

PLINQ的并行线程数默认是根据当前计算机的处理器核心数，可以使用WithDegreeOfParallelism

方法设置并行度。

一般来说，PLINQ会把已经算出来的某些结果先放进缓冲区中，稍后公布给消费线程。可以使用

WithMergeOptions方式建议PLINQ使用其他缓冲方式。是建议，可能被PLINQ忽略。

即使有了PLINQ，但是并行算法依然不好设计，设计不好也不会提高效率。应该做的是寻找程序中的循环或者其他能够用并行方式来处理的任务，试着改用并行版本，再衡量效果。

##### 处理并行算法的异常

并行算法抛出的异常是由AggregateException包裹着。如果并行操作不止一项，AggregateException会嵌套。

```C#
 class Program
    {
        static void Main(string[] args)
        {
            try
            {
                var answer = (from n in ParallelEnumerable.Range(0, 300)
                              where n.SomeTest()
                              select n.SomeProjection()).Skip(10).Take(20);

                var iter = answer.GetEnumerator();
                Console.WriteLine("start iterating");
                while (iter.MoveNext())
                {
                    Console.WriteLine("called MoveNext");
                    Console.WriteLine(iter.Current);
                }
            }
            catch(AggregateException ex)
            {
                ReportAggregateException(ex); //如果有多项并行操作，该递归，否则不递归也可以，递归的可以通用
            }
                   
        }     

        private static void ReportAggregateException(AggregateException aggregateException)
        {
            foreach(var exception in aggregateException.InnerExceptions)
            {
                if(exception is AggregateException agEx)
                {
                    ReportAggregateException(agEx);
                    Console.WriteLine("嵌套了");
                }
                else
                {
                    Console.WriteLine(exception.Message);
                }
            }
        }
    }


```

如果希望有些异常想抛出给调用者，而有些异常当前方法处理掉就算了，可以用字典`Dictionary<Type,Action<Exception>>`，针对不同的异常，有不同的处理。

```C#
static void Test()
{
    try
            {
                var answer = (from n in ParallelEnumerable.Range(0, 300)
                              where n.SomeTest()
                              select n.SomeProjection()).Skip(10).Take(20);

                var iter = answer.GetEnumerator();
                Console.WriteLine("start iterating");
                while (iter.MoveNext())
                {
                    Console.WriteLine("called MoveNext");
                    Console.WriteLine(iter.Current);
                }
            }
            catch (AggregateException ex)
            {
                var handlers = new Dictionary<Type, Action<Exception>>();
                handlers.Add(typeof(WebException), error => Console.WriteLine(error.Message));

                if (!HandleAggregateError(ex, handlers))
                {
                    throw;
                }
            }
}

private static bool HandleAggregateError(AggregateException error, Dictionary<Type, Action<Exception>> errorHandles)
{
    foreach (var exception in error.InnerExceptions)
    {
        if (exception is AggregateException agEx)
        {
            if (!HandleAggregateError(agEx, errorHandles))
            {
                return false;
            }
            else
            {
                continue;
            }
        }
        else if (errorHandles.ContainsKey(exception.GetType()))
        {
            errorHandles[exception.GetType()](exception);
        }
        else
        {
            return false;
        }
    }
    return true;
}

```

考虑详细一点的话，还可以在并行任务里面处理异常，至于哪些异常需要抛出去，哪些不需要，好好衡量。

##### 线程池优于创建新线程

线程的数量等于目标计算机的CPU核心数，未必效率最高，还有其他资源争夺也会影响最佳线程数。

编写多线程代码时，如果可以并行，最好使用[任务并行库](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)，让这个底层程序库管理线程池，它可以根据当前可供使用的系统资源来适当的启动任务。

关于性能：任务库>单独创建线程池（线程可重复使用）>单独创建线程（线程不能重复使用）

```C#
 
            //第一种 Task.Run
            //var tasks = new List<Task>();
            //tasks.Add(Task.Run(() => { }));
            //tasks.Add(Task.Run(() => { }));
            //tasks.Add(Task.Run(() => { }));
            //await Task.WhenAll(tasks);

            string answer = "";
            int threads = 4;

            using (AutoResetEvent e = new AutoResetEvent(false))
            {                
                //第二种 线程池
                //System.Threading.ThreadPool.QueueUserWorkItem((e0) => {  }, "nn0");
                //System.Threading.ThreadPool.QueueUserWorkItem((e1) => { }, "nn1");
                //System.Threading.ThreadPool.QueueUserWorkItem((e2) => { answer=e2.ToString(); e.Set(); }, "nn2");
                //e.WaitOne();

                //创建新线程
                System.Threading.Thread thread = new Thread(() => { });
                thread.Start();
                System.Threading.Thread thread1 = new Thread(() => { });
                thread1.Start();
                System.Threading.Thread thread2 = new Thread(() => { if (Interlocked.Decrement(ref threads) == 0) e.Set(); });
                thread2.Start();
                System.Threading.Thread thread3 = new Thread(() => { });
                thread3.Start();

                e.WaitOne();
            }          
```

##### BackgroundWorker

[Microsoft BackgroundWorker](https://docs.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc221403(v=vs.95)?redirectedfrom=MSDN)

[BackgroundWorker详细使用举例](https://www.cnblogs.com/sparkdev/p/5906272.html)

```C#
 static void Main(string[] args)
        {
            BackgroundWorker worker = new BackgroundWorker();
            //运行
            worker.DoWork += (object sender, DoWorkEventArgs e) =>
            {
                BackgroundWorker backgroundWorker = sender as BackgroundWorker;
                int sum = 0;
                for (int i = 0; i <= (int)e.Argument; i++)
                {
                    if (i % 10 == 0)
                    {
                        backgroundWorker.ReportProgress(i / 10, "客官稍等片刻，正在加速运行...");
                    }
                    sum += i;
                }
            };
            worker.WorkerReportsProgress = true; //进度
            worker.ProgressChanged += (object sender, ProgressChangedEventArgs e) =>
            {
                Console.WriteLine($"当前进度：{e.ProgressPercentage}，{ e.UserState.ToString()}");
            };
            worker.RunWorkerAsync(100); //开始运行
            Console.ReadLine();
        }
```

```C#
        BackgroundWorker worker = new BackgroundWorker();
            //运行
            worker.DoWork += (object sender, DoWorkEventArgs e) =>
            {
                BackgroundWorker backgroundWorker = sender as BackgroundWorker;
                int sum = 0;
                for (int i = 0; i <= (int)e.Argument; i++)
                {                    
                    sum += i;
                }
                Thread.Sleep(3000);
                if (worker.CancellationPending == true) //取消判断
                {
                    return;
                }
                for (int i = 0; i <= (int)e.Argument; i++)
                {
                    sum += i;
                }
            };

            worker.WorkerSupportsCancellation = true;  //支持取消
            worker.RunWorkerAsync(100); //开始运行
            worker.CancelAsync();  //取消
            Console.ReadLine();
```

##### WPF和Winform的跨线程调用

同步的Invoke和异步的BeginInvoke、EndInvoke方法。

WPF通用跨线程静态类设计，使用Dispatcher判断线程。

```C#
 public static class XAMLControlExtensions
    {
        public static void InvokeIfNeed(this System.Windows.Threading.DispatcherObject dispatcherObject,
            Action doit,System.Windows.Threading.DispatcherPriority priority)
        {
            if(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread) 
            {
                dispatcherObject.Dispatcher.Invoke(priority, doit);//同步
            }
            else
            {
                doit();
            }
        }
        public static void InvokeIfNeed<T>(this System.Windows.Threading.DispatcherObject dispatcherObject,
            Action<T> action,T args,System.Windows.Threading.DispatcherPriority priority)
        {
            if(System.Threading.Thread.CurrentThread != dispatcherObject.Dispatcher.Thread)
            {
                dispatcherObject.Dispatcher.Invoke(priority, action, args);//同步，回到UI线程执行action
            }
            else
            {
                action(args);
            }
        }
    }
```

Winform跨线程调用静态类设计、使用InvokeRequire判断

```C#
   public static class ControlExtensions
    {
        public static void InvokeIfNeed(this Control control,Action action)
        {
            //???
            if(control.IsHandleCreated == false)
            {
                action();
            }
            else if(control.InvokeRequired){
                control.Invoke(action);
            }
            else
            {
                action();
            }
        }

        public static void InvokeIfNeed<T>(this Control control, Action<T> action,T args)
        {
            //???
            if (control.IsHandleCreated == false)
            {
                action(args);
            }
            else if (control.InvokeRequired)
            {
                control.Invoke(action,args);
            }
            else
            {
                action(args);
            }
        }
        public static void InvokeAsync(this Control control,Action action)
        {
            //异步
            control.BeginInvoke(action);
        }
        public static void InvokeAsync<T>(this Control control, Action<T> action,T args)
        {
            control.BeginInvoke(action,args);
        }
    }
```

Winform通过InvokeRequired判断，如果控件已经创建，InvokeRequired判断会很迅速，如果控件还没完全创建好，会多花一点时间，但整个程序一个控件都还没创建成功，那InvokeRequired可能会返回错误值。

WPF通过Dispacher判断，已经对某些特殊情况做了优化，比Winform的要好。

Invoke方法，会像目标Control的消息队列投递消息，把delegate需要的内容放进去，放进去的参数是副本。当目标控件处理消息时，会处理整个队列的消息。Invoke方法会反复去查询结果。如果目标控件同时有BeginInvoke和Invoke消息，容易出问题。

WPF可以通过DispatcherPriority设置消息执行的优先级。







