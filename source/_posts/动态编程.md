---
title: 动态编程
date: 2020-02-04 16:54:23
tags:
---

##### 动态编程的优缺点

假如实现一通用加法，参数类型只要求支持特定的操作符，使用泛型是无法实现这种约束的，但动态类型就灵活很多了。

```C#
  public static dynamic Add(dynamic a, dynamic b) //动态类型
  {
  	 return a + b; //在运行时才会对类型进行解析。
  }
```

但是运行时才对动态类型解析，因此问题也会延迟暴露。

连锁的动态类型，运算过程中如果有动态类型，那结果也是动态类型，要变成静态类型，只能自己转换类型。（缺 可能C#7.0以后可以自动转了，C#7.3可以自动转）

如果编码无法提前知道对象的类型，并且在运行时要调用某个特定的方法，可以考虑动态编程。其他情应使用lambda表达式或其他函数式编程实现。（建议）

```C#
 public static void Main(string[] args)
 {
     var lambdaAnswer = Add(3, 3, (a, b) => a + b);  //传入lambda表达式1
     var lambdaAnswer1 = Add("args", 3, (a, b) => a + b.ToString());//传入lambda表达式2
     var lambdaAnswer1 = Add(4, 3.4m, (a, b) => a + (int)b);//传入lambda表达式3     
 }      

public static TResult Add<T1,T2,TResult>(T1 left,T2 right,Func<T1,T2,TResult> addMethod)
{
    return addMethod(left, right);
}
```

上面的表达式可以衍生出表达式树的写法

```C#
public static class BinaryOperator<T>  //如果操作数和运算结果同一类型，建议该写法
{
    static Func<T,T,T> compiledExpression; //缓存
    public static T Add(T left, T right)
    {
        if (compiledExpression == null)
        {
            CreatFunc();
        }
        return compiledExpression(left, right);
    }

    private static void CreatFunc()
    {
        var leftOperand = Expression.Parameter(typeof(T), "left");
        var rightOperand = Expression.Parameter(typeof(T), "right");
        var body = Expression.Add(leftOperand, rightOperand);
        var adder = Expression.Lambda<Func<T,T,T>>(body, leftOperand, rightOperand);
        compiledExpression = adder.Compile();
    }
}

 public static class BinaryOperator<T1, T2, TResult>
 {
     static Func<T1, T2, TResult> compiledExpression;
     public static TResult Add(T1 left,T2 right)
     {
         if (compiledExpression == null)
         {
             CreatFunc();
         }
         return compiledExpression(left, right);
     }

     private static void CreatFunc()
     {
         var leftOperand = Expression.Parameter(typeof(T1), "left");
         var rightOperand = Expression.Parameter(typeof(T2), "right");

         Expression convertedLeft = leftOperand;
         if (typeof(T1) != typeof(TResult))
         {
             convertedLeft = Expression.Convert(leftOperand, typeof(TResult)); //转换
         }
         Expression convertedRight = rightOperand;
         if (typeof(T2) != typeof(TResult))
         {
             convertedRight = Expression.Convert(rightOperand, typeof(TResult));
         }

         var body = Expression.Add(convertedLeft, convertedRight);
         var adder = Expression.Lambda<Func<T1, T2, TResult>>(body, leftOperand, rightOperand); 
         compiledExpression = adder.Compile();
     }
 }
```

C#写出的动态程序（例如表达式树、dynamic...）都是在运行时做检查，效率是没有静态类型的快。

先静后动：通过接口或基类实现，lambda表达式，表达式树，动态类型。

##### 动态编程技术可以帮助运行泛型参数的运行期类型的运用

在`System.Core`程序集里，`System.Linq.Enumerable.Cast<T>`的扩展方法可以把序列中的每个元素转换成T类型，但是如果对T没有约束，`Cast<T>`方法只能认定T类型含有的那些`System.Object`的成员。

```C#
 class Program
    {
        public static void Main(string[] args)
        {
            List<string> strList = new List<string>();
            strList.Add("aa");
            strList.Add("bb");
            strList.Add("cc");

            var results = strList.Cast<MyType>(); //惰性 延迟转换
            
            //和上面写法一个意思
            //var results = from MyType v in strList  
                           //select v;
            try
            {
                foreach(var item in results)  
                {
                    Console.WriteLine(item);
                }
            }
            catch(InvalidCastException) //无效转换异常
            {
                Console.WriteLine("failed");
            }
        }
    }

//结果运行失败

    public class MyType
    {
        public string StringMember { get; set; }

        //不推荐设计Api时使用隐式转换器
        public static implicit operator String(MyType aString) => aString.StringMember;

        public static implicit operator MyType(String aString) => new MyType { StringMember = aString };
    }
```

```C#
 public static void Main(string[] args)
 {
     List<string> strList = new List<string>();  
     //是System.Object含有的那些成员，不会报无效转换异常。
     
     strList.Add("aaa");

     var results = strList.Cast<string>(); 

     foreach (var item in results)
     {
         Console.WriteLine(item);
     }
 }
```

解决办法1：

```C#
var results = from MyType v in strList  
                           select v;
换成
var results = from v in strList  
                           select (MyType)v;  //select方法接受的是lambda表达式，对于v来说，lambda表达式是string类型的对象
```

解决办法2：`strList.Select(a => new MyType { StringMember = a });`

解决办法3：使用构造函数。

解决办法4：大量反射代码，知道拿到转换器，但是效率不如动态类型。

最后：动态类型

```C#
/// <summary>
/// 枚举扩展类
/// </summary>
public static class EnumerableExtension
{
    public static IEnumerable<TResult> Convert<TResult>(this System.Collections.IEnumerable sequence)
    {
        foreach(object item in sequence)
        {
            dynamic result = (dynamic)item;
            yield return (TResult)result; //yield 迭代返回
        }
    }
}
```

